<?xml version="1.0" encoding="utf-8"?>
<spec xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:style="http://siyavula.com/cnxml/style/0.1">

  <entry>
    <xpath>//para</xpath>
    <children>
      <reference>inline-container-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
text = ' '.join(self.text.strip().split())
pos = text.find('"')
if pos != -1:
    warning_message('Straight double quote in text, consider replacing with left/right quotes: %s'%repr(text[pos-20:pos+20]))
# check if para doesn't only contain a \\
if text.strip() == r'\\':
    text = text.replace(r'\\', r'')
return '\\par\n' + text + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
text = ' '.join(self.text.strip().split())
newElement = etree.Element('p')
newElement.text = self.text.strip()
return '\n' + etree.tostring(newElement) + '\n'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//list</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>list-type</name>
	<type>enum("bulleted","enumerated")</type>
	<default>bulleted</default>
      </entry>
      <entry>
	<name>bullet-style</name>
	<type>enum("bullet", "open-circle", "pilcrow", "rpilcrow", "asterisk", "dash", "section", "none")</type>
	<default>bullet</default>
      </entry>
      <entry>
	<name>start-value</name>
	<type>integer(1,)</type>
	<default>1</default>
      </entry>
      <entry>
	<name>mark-prefix</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>number-style</name>
	<type>enum("arabic","upper-alpha","lower-alpha","upper-roman","lower-roman")</type>
	<default>arabic</default>
      </entry>
      <entry>
	<name>bullet-style</name>
	<type>enum("bullet","open-circle")</type>
	<default>bullet</default>
      </entry>
    </attributes>
    <children>
      <any-number from="1">
	<element>item</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
listType = self.attrib['list-type']
if listType == 'bulleted':
    environment = 'ListBulleted'
elif listType == 'enumerated':
    environment = 'ListEnumerated'
startval = self.attrib.get('start-value')
if startval == '1':
    startval = ''
else:
    startval = r'\setcounter{enumi}{%s}' % str(int(startval)-1)

return '\n\\begin{' + environment + '}\n%s' % startval + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
listType = self.attrib['list-type']
if listType == 'bulleted':
    environment = 'ListBulleted'
    newlist = etree.Element('ul')
elif listType == 'enumerated':
    environment = 'ListEnumerated'
    newlist = etree.Element('ol')

newlist.text = self.text
newlist.attrib['data-class'] = environment

return etree.tostring(newlist)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//list/item</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner correct teacher">
return r'\item ' + self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
newitem = etree.Element('li')
newitem.text = self.text
newitem.tail = '\n'
return etree.tostring(newitem)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//table</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>frame</name>
	<type>enum("none",)</type>
	<default/>
      </entry>
      <entry>
	<name>colsep</name>
	<type>integer</type>
	<default/>
      </entry>
      <entry>
	<name>rowsep</name>
	<type>integer</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <element>tgroup</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
tabularNewline = r'\tabularnewline'
columnAlignment = eval(self.attrib['latexColumnAlignment'])
return r'\par'+'\n'+r'\begin{Table}{|' + '|'.join(columnAlignment) + '|}\n' + self.text + tabularNewline + '\n' + r'\hline' + '\n' + r'\end{Table}' + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
table = etree.Element('table')
# if the next tag is caption, add it as table summary text.
if self.getnext() is not None:
    if self.getnext().tag == 'caption':
        table.attrib['summary'] = self.getnext().text
table.text = self.text
return etree.tostring(table)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//table/tgroup</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>cols</name>
	<type>integer(1,)</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <any-number from="1">
	<element>colspec</element>
      </any-number>
      <element>tbody</element>
    </children>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
cols = self.attrib.get('cols')
if cols is not None:
    if self.attrib.get('columnCount') is not None:
        assert self.attrib.get('columnCount') == cols, "Table column count specified in 'cols' attribute does not match number of columns in colspec."
    else:
        self.attrib['columnCount'] = cols
parentAttrib = self.getparent().attrib
parentAttrib['columnCount'] = self.attrib['columnCount']
parentAttrib['latexColumnAlignment'] = self.attrib['latexColumnAlignment']
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//table/tgroup/colspec</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>colname</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>colnum</name>
	<type>integer(1,)</type>
      </entry>
      <entry>
	<name>colwidth</name>
	<type>string</type> <!-- 475.4 -->
	<default/>
      </entry>
      <entry>
	<name>style:latex-alignment</name>
	<type>string</type>
	<default/> <!-- default: c -->
      </entry>
    </attributes>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
parentAttrib = self.getparent().attrib
parentAttrib['columnCount'] = str(int(parentAttrib.get('columnCount', '0')) + 1)
columnSpec = eval(parentAttrib.get('columnSpec', '{}'))
columnSpec[self.attrib.get('colname')] = int(self.attrib['colnum'])-1
parentAttrib['columnSpec'] = repr(columnSpec)

latexAlignmentKey = '{http://siyavula.com/cnxml/style/0.1}latex-alignment'
if parentAttrib.get('latexColumnAlignment') is None:
    parentAttrib['latexColumnAlignment'] = '[]'
if self.attrib.get(latexAlignmentKey) is None:
    colwidth = self.attrib.get('colwidth')
    if colwidth is not None:
        # Set LaTeX column width based on colwidth attribute
        try:
            assert colwidth[-2:] == 'pt'
        except AssertionError:
            # hack in a default value
            colwidth = '150pt'
        colwidth = float(colwidth[:-2])
        relativeWidth = colwidth / 480
        self.attrib[latexAlignmentKey] = r'&gt;{\centering}p{%.6f\textwidth}'%(0.85*relativeWidth)
    else:
        # Set default value
        self.attrib[latexAlignmentKey] = 'c'
parentAttrib['latexColumnAlignment'] = repr(eval(parentAttrib['latexColumnAlignment']) + [self.attrib[latexAlignmentKey]])

return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//table/tgroup/tbody</xpath>
    <children>
      <any-number>
	<element>row</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
tabularNewline = r'\tabularnewline'
text = self.text.strip()
assert text[-len(tabularNewline):] == tabularNewline, "Weird latex table error in //table/tgroup/tbody conversion."
return text[:-len(tabularNewline)] + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
    return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//table/tgroup/tbody/row</xpath>
    <children>
      <any-number>
	<element>entry</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
tabularNewline = r'\tabularnewline'
text = self.text.strip()
assert text[-1] == '&amp;', "Weird latex table error in //table/tgroup/tbody/row conversion."
return '\\hline\n' + text[:-1] + tabularNewline + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
row = etree.Element('tr')
row.text = self.text
return etree.tostring(row)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//table/tgroup/tbody/row/entry</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>namest</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>nameend</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>align</name>
	<type>enum("center",)</type>
	<default/>
      </entry>
      <entry>
	<name>morerows</name>
	<type>integer</type>
	<default>0</default>
      </entry>
    </attributes>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner correct teacher">
multiColumnStart = self.attrib.get('namest')
multiColumnEnd = self.attrib.get('nameend')
moreRows = int(self.attrib['morerows'])
if (multiColumnStart is not None) and (multiColumnEnd is not None):
    if moreRows &gt; 0:
        error_message('Cannot handle table entries that span multiple rows and columns')
    columnSpec = eval(self.getparent().getparent().getparent().attrib.get('columnSpec'))
    columnCount = columnSpec[multiColumnEnd] - columnSpec[multiColumnStart] + 1
else:
    columnCount = 1
if columnCount &gt; 1:
    return r'\multicolumn{' + str(columnCount) + r'}{|c|}{' + self.text.strip() + r'} &amp;'
else:
    if moreRows &gt; 0:
        text = self.text.strip()
        while text[:4] == r'\par':
            text = text[4:].lstrip()
        while text[-4:] == r'\par':
            text = text[:-4].rstrip()
        return r'\multirow{' + str(moreRows+1) + '}{*}{' + text + r'} &amp;'
    else:
        return self.text.strip() + ' &amp;'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
td = etree.Element('td')
multiColumnStart = self.attrib.get('namest')
multiColumnEnd = self.attrib.get('nameend')
moreRows = int(self.attrib['morerows'])
if (multiColumnStart is not None) and (multiColumnEnd is not None):
    if moreRows &gt; 0:
        error_message('Cannot handle table entries that span multiple rows and columns')
    columnSpec = eval(self.getparent().getparent().getparent().attrib.get('columnSpec'))
    columnCount = columnSpec[multiColumnEnd] - columnSpec[multiColumnStart] + 1
else:
    columnCount = 1
if columnCount &gt; 1:
    td.text = self.text.strip()
    td.attrib['colspan'] = str(columnCount)
    return etree.tostring(td)
else:
    if moreRows &gt; 0:
        text = self.text.strip()
        while text[:4] == r'\par':
            text = text[4:].lstrip()
        while text[-4:] == r'\par':
            text = text[:-4].rstrip()
        td.text = text
        td.attrib['rowspan'] = str(moreRows+1)
        return etree.tostring(td)
    else:
        td.text = self.text.strip()
        return etree.tostring(td)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//presentation</xpath>
    <children>
      <unordered>
	<element>title</element>
	<optional>shortcode</optional>
	<element>url</element>
      </unordered>
    </children>
    <conversion-callback name="latex learner teacher">
return r'\presentation{' + self.attrib.get('shortcode', 'SHORTCODE') + '}{' + self.attrib.get('title', 'TITLE') + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
presentation = etree.Element('p')
presentation.attrib['data-class'] = 'presentation'
presentation.attrib['id'] = 'sc' + self.attrib.get('shortcode', 'SHORTCODE')
url = etree.Element('a')
url.attrib['href'] = self.attrib.get('url')
url.text = 'Presentation: %s'%self.attrib.get('shortcode')
presentation.text = '%s'% etree.tostring(url)


return etree.tostring(presentation)
</conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>//presentation/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>//presentation/shortcode</xpath>
    <validation-callback>is_rich_media_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['shortcode'] = self.text
return ''
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>//presentation/url</xpath>
    <conversion-callback name="latex learner teacher"/>
    <conversion-callback name="html learner teacher">
self.getparent().attrib['url'] = self.text
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>//simulation</xpath>
    <children>
      <unordered>
	<element>title</element>
	<optional>shortcode</optional>
	<element>url</element>
	<element>embed</element>
	<optional>width</optional>
	<optional>height</optional>
      </unordered>
    </children>
    <validation-callback>simulation_has_url_or_embed</validation-callback>
    <conversion-callback name="latex learner teacher">
return r'\simulation{' + self.attrib.get('shortcode', 'SHORTCODE') + '}{' + self.attrib.get('title', 'TITLE') + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
simulation = etree.Element('p')
simulation.attrib['data-class'] = 'simulation'
simulation.attrib['id'] = 'sc' + self.attrib.get('shortcode', 'SHORTCODE')
url = etree.Element('a')
url.attrib['href'] = self.attrib.get('url')
url.text = 'Simulation: %s'%self.attrib.get('shortcode')
simulation.text = '%s'% etree.tostring(url)

return etree.tostring(simulation)
</conversion-callback>
  </entry>

  <entry>
    <xpath>//simulation/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//simulation/shortcode</xpath>
    <validation-callback>is_rich_media_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['shortcode'] = self.text
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//simulation/width</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner teacher"/>
  </entry>

  <entry>
    <xpath>//simulation/height</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner teacher"/>
  </entry>

  <entry>
    <xpath>//simulation/url</xpath>
    <conversion-callback name="latex learner teacher"/>
    <conversion-callback name="html learner teacher">
    self.getparent().attrib['url'] = self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//simulation/embed</xpath>
    <validation-callback>is_valid_html</validation-callback>
    <conversion-callback name="latex html learner teacher"/>
  </entry>

  <entry>
    <xpath>//video</xpath>
    <children>
      <unordered>
	<element>title</element>
	<any-number from="1"><!-- with multiple urls, the first one will be linked to and the rest are for reference only -->
	  <element>url</element>
	</any-number>
	<optional>shortcode</optional>
	<optional>width</optional>
	<optional>height</optional>
      </unordered>
    </children>
    <conversion-callback name="latex learner teacher">
return r'\video{' + self.attrib.get('shortcode', 'SHORTCODE') + '}{' + self.attrib.get('title', 'TITLE') + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
video = etree.Element('p')
video.attrib['data-class'] = 'video'
video.attrib['id'] = 'sc' + self.attrib.get('shortcode', 'SHORTCODE')
url = etree.Element('a')
url.attrib['href'] = self.attrib.get('url')
url.text = 'Video: %s'%self.attrib.get('shortcode')
video.text = '%s'% etree.tostring(url)

return etree.tostring(video)
</conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>//video/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>//video/shortcode</xpath>
    <validation-callback>is_rich_media_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['shortcode'] = self.text
return ''
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>//video/url</xpath>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['url'] = self.text
</conversion-callback>
  </entry>

  <entry>
    <xpath>//video/width</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//video/height</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//figure</xpath>
    <children>
      <element>type</element>
      <any-number from="1">
	<one-of>
	  <element>table</element>
	  <element>pspicture</element>
	  <element>tikzpicture</element>
	  <element>image</element>
	  <element>para</element>
	  <element>equation</element>
	  <element>latex</element>
	</one-of>
      </any-number>
      <optional>caption</optional>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher"><!-- type already creates start of environment -->
environment = 'Figure' + self.attrib['type'].capitalize()
result = '\n\\begin{' + environment + '}\n' + self.text
id = self.attrib.get('id')
if id is not None:
    result += r'\label{' + id + '}\n'
result += r'\end{' + environment + '}\n'
return result
    </conversion-callback>
    <conversion-callback name="html learner correct teacher"><!-- type already creates start of environment -->
# if the figure contains an image
if self.attrib['type'] == 'figure':
    figure = etree.Element('figure')
    figure.text = self.text
else:
    environment = 'Figure' + self.attrib['type'].capitalize()
    figure = etree.Element('div')
    figure.attrib['data-class'] = environment
    figure.text = self.text

id = self.attrib.get('id')
if id is not None:
    figure.attrib['id'] = id
return etree.tostring(figure)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//pspicture</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>style:width</name>
	<type>number</type>
	<default/>
      </entry>
      <entry>
	<name>crop</name>
	<type>enum("true","false")</type>
	<default>false</default>
      </entry>
    </attributes>
    <children>
      <any-number>
	<element>usepackage</element>
      </any-number>
      <element>code</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
redBoundingBox = False # Put red frame at bounding box of every pspicture?

if self.attrib['crop'] == 'true':
    pspictureEnvironment = 'pspicture*'
else:
    pspictureEnvironment = 'pspicture'

tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
if self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width') is not None:
    relativeWidth = float(self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width'))
    # Get width of pspicture
    start = self.text.find('(')+1
    stop = self.text.find(',', start)
    xmin = float(self.text[start:stop])
    start = self.text.find('(', stop)+1
    stop = self.text.find(',', start)
    xmax = float(self.text[start:stop])
    pspictureWidthInCm = xmax-xmin
    pspictureWidthInPt = pspictureWidthInCm * 28.3464567
    head += r'\FPdiv\scaleparam{\getlengthinpt{\textwidth}}{' + str(pspictureWidthInPt/relativeWidth) + r'}\par\par\scalebox{\scaleparam}{\begin{' + pspictureEnvironment + '}'
    tail = r'\end{' + pspictureEnvironment + '}}\n' + tail
else:
    head += r'\par\begin{' + pspictureEnvironment + '}'
    tail = r'\end{' + pspictureEnvironment + '}\n' + tail

if redBoundingBox:
    start = self.text.find('(')
    stop = self.text.find(')', start)
    stop = self.text.find(')', stop+1)+1
    nextLine = self.text.find('\n', stop)+1
    text = self.text[:nextLine] + r'\psframe[linecolor=red]' + self.text[start:stop] + '\n' + self.text[nextLine:]
else:
    text = self.text

return head + text + tail
    </conversion-callback>
    <conversion-callback name="latex correct">
if self.attrib['crop'] == 'true':
    pspictureEnvironment = 'pspicture*'
else:
    pspictureEnvironment = 'pspicture'

tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'

relativeWidth = 1
# Get width of pspicture
start = self.text.find('(')+1
stop = self.text.find(',', start)
xmin = float(self.text[start:stop])
start = self.text.find('(', stop)+1
stop = self.text.find(',', start)
xmax = float(self.text[start:stop])
pspictureWidthInCm = xmax-xmin
pspictureWidthInPt = pspictureWidthInCm * 28.3464567
head += r'\FPdiv\scaleparam{\getlengthinpt{\linewidth}}{' + str(pspictureWidthInPt/relativeWidth) + r'}\par\par\scalebox{\scaleparam}{\begin{' + pspictureEnvironment + '}'
tail = r'\end{' + pspictureEnvironment + '}}\n' + tail

return head + self.text + tail
    </conversion-callback>
    <conversion-callback name="html learner teacher">
code = self.find('.//code').text
#TODO fix this, image names don't match the actual names.
# bad hack, strip out all non-ascii characters from code element to calculate hash
codetext = ''.join([c  for c in code if ord(c) &lt; 128])
codeHash = hashlib.md5(''.join(codetext.encode('utf-8').split())).hexdigest()

pre = etree.Element('pre')
pre.attrib['class'] = 'pspicture'
code_element = self.find('.//code')
pre.append(copy.deepcopy(code_element))

pspicture = etree.Element('div')
pspicture.attrib['class'] = 'alternates'

img = etree.Element('img')
img_path = '_plone_ignore_/cache/pspictures/%s.png'%codeHash
# check if the file has been created already
try:
    with open(img_path): pass
# if not, create the file
except IOError:
    try:
        png = pspicture2png(self)
        os.system('cp %s %s' % (png, img_path))
    except Exception as E:
        warning_message("Problem compiling pstricks\n\nException:\n%s\n\n" % E + etree.tostring(self))
        png = ''

img.attrib['src'] = img_path
#if width is not None:
#    img.attrib['width'] = str(int(float(width)*780))
#else:
#    img.attrib['width'] = '780'
#
#img.attrib['alt'] = self.attrib.get('attribution')

# add usepackages to pre element


for up in self.findall('.//usepackage'):
    pre.append(up)

pspicture.append(img)
pspicture.append(pre)
return etree.tostring(pspicture)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//pspicture/usepackage</xpath>
    <conversion-callback name="latex learner correct teacher">
if self.text.strip() not in ['pst-solides3d', 'pst-3dplot', 'pst-node']:
    warning_message('REQUIRED PSTRICKS PACKAGE: ' + self.text)
return ''
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return 
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//pspicture/code</xpath>
    <children>
      <any-number>
	<one-of>
	  <element>unit_number</element>
	  <element>number</element>
	  <element>unit</element>
	  <element>percentage</element>
	  <element>currency</element>
	  <element>chem_compound</element>
	  <element>spec_note</element>
	  <element>nuclear_notation</element>
	  <element>nth</element>
	</one-of>
      </any-number>
    </children>
    <conversion-callback name="latex learner correct teacher">
return self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return 
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//tikzpicture</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>style:width</name>
	<type>number</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <any-number>
	<element>usepackage</element>
      </any-number>
      <element>code</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
if self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width') is not None:
    warning_message('UNHANDLED style:width in tikzpicture')
return head + r'\par\begin{tikzpicture}' + self.text + r'\end{tikzpicture}' + '\n' + tail
    </conversion-callback>
    <conversion-callback name="latex correct">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
return head + r'\par\scalebox{0.5}{\begin{tikzpicture}' + self.text + r'\end{tikzpicture}}' + '\n' + tail
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//tikzpicture/usepackage</xpath>
    <conversion-callback name="latex learner correct teacher">
warning_message('REQUIRED TIKZ PACKAGE: ' + self.text)
return ''
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
usepackage = etree.Element('usepackage')
usepackage.text = self.text
return etree.tostring(usepackage)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//tikzpicture/code</xpath>
    <children>
      <any-number>
	<one-of>
	  <element>unit_number</element>
	  <element>number</element>
	  <element>unit</element>
	  <element>percentage</element>
	  <element>currency</element>
	  <element>chem_compound</element>
	  <element>spec_note</element>
	  <element>nuclear_notation</element>
	  <element>nth</element>
	</one-of>
      </any-number>
    </children>
    <conversion-callback name="latex learner correct teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//image</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>style:width</name>
	<type>number</type>
	<default/>
      </entry>
      <entry>
        <name>src</name>
        <type>string</type>
        <default/>
      </entry>
      <entry>
        <name>width</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>height</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>mime-type</name>
        <type>string</type>
        <default/>
      </entry>
      <entry>
        <name>src</name>
        <type>string</type>
        <default/>
      </entry>
      <entry>
        <name>width</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>height</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>mime-type</name>
        <type>string</type>
        <default/>
      </entry>
      <!--<entry>
	<name>style:format</name>
	<type>string</type>
	<default/>
      </entry>-->
    </attributes>
    <children>
      <subset-of>
        <element>src</element>
        <element>attribution</element>
      </subset-of>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
result = r'\includegraphics'
width = self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width')
if width is not None:
    result += r'[width=%s\textwidth]'%width
else:
    width = self.attrib.get('width')
    if width is not None:
        result += r'[width=%s\textwidth]'%(float(width)/800.0)
result += '{' + self.attrib['src'] + '}\n'
if self.attrib.has_key('attribution'):
    result += r'\ImageAttribution{' + self.attrib['attribution'] + '}\n'
return head + result + tail
    </conversion-callback>
    <conversion-callback name="html learner teacher">
width = self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width')
img = etree.Element('img')
img.attrib['src'] = self.attrib['src']
if width is not None:
    img.attrib['width'] = str(int(float(width)*780))
else:
    img.attrib['width'] = '300'

if self.attrib.get('attribution') is not None:
    img.attrib['alt'] = self.attrib.get('attribution')

return etree.tostring(img)
</conversion-callback>
    <conversion-callback name="latex correct">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
result = r'\includegraphics'
result += r'[width=\linewidth]'
result += '{' + self.attrib['src'] + '}\n'
return head + result + tail
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//image/src</xpath>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['src'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//image/attribution</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['attribution'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//figure/type</xpath>
    <validation-callback>is_figure_type</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['type'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//figure/caption</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner correct teacher">
if self.text.strip().startswith(r'\par'):
    self.text = self.text.strip()[4:]
return r'  \Caption{' + self.text.strip() + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
if self.getparent().attrib['type'] == 'figure':
    caption = etree.Element('figcaption')
else:
    caption = etree.Element('div')

caption.attrib['class'] = 'caption'
caption.text = self.text

return '\n'+etree.tostring(caption)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//latex</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>display</name>
	<type>enum("inline","block")</type>
	<default>inline</default>
      </entry>
    </attributes>
    <children>
      <any-number>
	<one-of>
	  <element>number</element>
	  <element>unit</element>
	  <element>unit_number</element>
	  <element>percentage</element>
	  <element>currency</element>
	  <element>correct</element>
	</one-of>
      </any-number>
    </children>
    <conversion-callback name="latex learner correct teacher">
# First check that there aren't any funny functions
unslashedFunctions = latex_math_function_check(self.text)
if len(unslashedFunctions) > 0:
    warning_message('Found the following functions: (%s) without a backslash in a latex element:\n%s'%(', '.join(unslashedFunctions), self.text))

insideTable = ('table' in utils.get_full_dom_path(self))

numberEquations = False
if self.attrib['display'] == 'inline':
    return r'\(' + self.text.strip() + r'\)'
else:
    foundMathEnvironment = False
    text = self.text.strip()
    beginPattern = r'\begin{%s}'
    endPattern = r'\end{%s}'
    for environmentName in ['align', 'align*', 'aligned', 'aligned*', 'equation', 'equation*', 'eqnarray', 'eqnarray*']:
        beginSubstr = beginPattern%environmentName
        if text[:len(beginSubstr)] == beginSubstr:
            endSubstr = endPattern%environmentName
            if text[-len(endSubstr):] != endSubstr:
                error_message('You are either missing a \\end{%s} in a LaTeX environment or there is a mismatch between the \\begin and \\end.'%environmentName)
            if environmentName in ['eqnarray', 'eqnarray*']:
                warning_message('You should really be using align rather eqnarray in your &lt;latex&gt; elements')

            # Normalise align
            if environmentName in ['align', 'align*', 'aligned', 'aligned*']:
                if insideTable:
                    replacement = 'aligned'
                else:
                    replacement = 'align'
                newBeginSubstr = beginPattern%replacement
                newEndSubstr = endPattern%replacement
                text = newBeginSubstr + text[len(beginSubstr):-len(endSubstr)] + newEndSubstr
                environmentName = replacement
                beginSubstr = newBeginSubstr
                endSubstr = newEndSubstr

            foundMathEnvironment = True
            if not numberEquations:
                if environmentName[-1] != '*':
                    text = beginSubstr[:-1] + '*}' + text[len(beginSubstr):-len(endSubstr)] + endSubstr[:-1] + '*}'
                    beginSubstr = beginSubstr[:-1] + '*}'
                    endSubstr = endSubstr[:-1] + '*}'
            break
    if not foundMathEnvironment:
        return '\\[' + text + '\\]\n'
    else:
        environmentsWithAmpersands = {'align': 1, 'align*': 1, 'eqnarray': 2, 'eqnarray*': 2}
        if environmentName in environmentsWithAmpersands:
            # Check number of ampersands per line
            ampersands = environmentsWithAmpersands[environmentName]
            lines = text.split('\\\\')
            for lineIndex in range(len(lines)):
                line = lines[lineIndex].strip()
                if line.count('&amp;') &gt; ampersands:
                    error_message('Extra ampersands (expected %i) in aligned equation: %s'%(ampersands, line))
                if (lineIndex == len(lines)-1) and (line == endSubstr):
                    error_message('Extra \\\\ at end of aligned equation: %s'%(text.strip()))
        return text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
def make_new_mathelement(TeX):
    mathmlelement = etree.Element('math')
    semantics = etree.Element('semantics')
    junk = etree.Element('mtext')
    junk.text = 'CLICKME'
    semantics.append(junk)
    annotation = etree.Element('annotation')
    annotation.attrib['encoding'] = 'TeX'
    annotation.text = TeX

    semantics.append(annotation)
    mathmlelement.append(semantics)
    return etree.tostring(mathmlelement)

# First check that there aren't any funny functions
unslashedFunctions = latex_math_function_check(self.text)
if len(unslashedFunctions) > 0:
    warning_message('Found the following functions: (%s) without a backslash in a latex element:\n%s'%(', '.join(unslashedFunctions), self.text))

insideTable = ('table' in utils.get_full_dom_path(self))

numberEquations = False
if self.attrib['display'] == 'inline':
    return make_new_mathelement(self.text.strip()) #r'\(' + self.text.strip() + r'\)'
else:
    foundMathEnvironment = False
    text = self.text.strip()
    beginPattern = r'\begin{%s}'
    endPattern = r'\end{%s}'
    for environmentName in ['align', 'align*', 'aligned', 'aligned*', 'equation', 'equation*', 'eqnarray', 'eqnarray*']:
        beginSubstr = beginPattern%environmentName
        if text[:len(beginSubstr)] == beginSubstr:
            endSubstr = endPattern%environmentName
            if text[-len(endSubstr):] != endSubstr:
                error_message('You are either missing a \\end{%s} in a LaTeX environment or there is a mismatch between the \\begin and \\end.'%environmentName)
            if environmentName in ['eqnarray', 'eqnarray*']:
                warning_message('You should really be using align rather eqnarray in your &lt;latex&gt; elements')

            # Normalise align
            if environmentName in ['align', 'align*', 'aligned', 'aligned*']:
                if insideTable:
                    replacement = 'aligned'
                else:
                    replacement = 'align'
                newBeginSubstr = beginPattern%replacement
                newEndSubstr = endPattern%replacement
                text = newBeginSubstr + text[len(beginSubstr):-len(endSubstr)] + newEndSubstr
                environmentName = replacement
                beginSubstr = newBeginSubstr
                endSubstr = newEndSubstr

            foundMathEnvironment = True
            if not numberEquations:
                if environmentName[-1] != '*':
                    text = beginSubstr[:-1] + '*}' + text[len(beginSubstr):-len(endSubstr)] + endSubstr[:-1] + '*}'
                    beginSubstr = beginSubstr[:-1] + '*}'
                    endSubstr = endSubstr[:-1] + '*}'
            break
    if not foundMathEnvironment:
        return make_new_mathelement(text) #r'\[' + text + r'\]'
    else:
        environmentsWithAmpersands = {'align': 1, 'align*': 1, 'eqnarray': 2, 'eqnarray*': 2}
        if environmentName in environmentsWithAmpersands:
            # Check number of ampersands per line
            ampersands = environmentsWithAmpersands[environmentName]
            lines = text.split('\\\\')
            for lineIndex in range(len(lines)):
                line = lines[lineIndex].strip()
                if line.count('&amp;') &gt; ampersands:
                    error_message('Extra ampersands (expected %i) in aligned equation: %s'%(ampersands, line))
                if (lineIndex == len(lines)-1) and (line == endSubstr):
                    error_message('Extra \\\\ at end of aligned equation: %s'%(text.strip()))
        return make_new_mathelement(text) #text

    </conversion-callback>
  </entry>

  <entry id="block-element-no-subsections">
    <children>
      <any-number>
	<reference>block-element-no-subsections-entry</reference>
      </any-number>
    </children>
  </entry>

  <entry id="block-element-no-subsections-entry">
    <children>
      <one-of>
	<element>media</element>
	<element>para</element>
	<element>video</element>
	<element>presentation</element>
	<element>simulation</element>
	<element>list</element>
	<element>equation</element>
	<element>latex</element>
	<element>worked_example</element>
	<!--<element>monassis-template</element>-->
	<element>figure</element>
	<element>image</element>
	<element>pspicture</element>
	<element>tikzpicture</element>
	<element>table</element>
	<element>html5table</element>
	<element>definition</element>
	<element>theorem</element>
	<element>activity</element>
	<element>exercises</element>
	<element>note</element>
	<element>math_extension</element>
	<element>math_identity</element>
	<element>key-concepts</element>
	<element>new-words</element>
	<element>linked-concepts</element>
	<element>teachers-guide</element>
	<element>correct</element>
    <element>link</element>
    <element>quote</element>

	<element>todo</element><!-- This needs to go away before publising the print textbooks -->
      </one-of>
    </children>
  </entry>

  <entry id="inline-container-element">
    <children>
      <any-number>
	<one-of>
	  <element>br</element>
      <element>space</element>
      <element>newline</element>
	  <element>chem_compound</element>
	  <element>correct</element>
	  <element>currency</element>
	  <element>emphasis</element>
	  <element>image</element>
	  <element>latex</element>
	  <element>link</element>
	  <element>list</element>
	  <element>m:math</element>
	  <element>nth</element>
	  <element>nuclear_notation</element>
	  <element>number</element>
	  <element>percentage</element>
	  <element>spec_note</element>
	  <element>sub</element>
	  <element>sup</element>
	  <element>unit_number</element>
	  <element>unit</element>

	  <element>todo</element><!-- This needs to go away before publising the print textbooks -->
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry id="inline-element">
    <children>
      <any-number>
	<one-of>
	  <element>br</element>
      <element>newline</element>
      <element>space</element>
	  <element>chem_compound</element>
	  <element>correct</element>
	  <element>currency</element>
	  <element>emphasis</element>
	  <element>image</element>
	  <element>latex</element>
	  <element>link</element>
	  <element>m:math</element>
	  <element>nth</element>
	  <element>nuclear_notation</element>
	  <element>number</element>
	  <element>percentage</element>
	  <element>spec_note</element>
	  <element>sub</element>
	  <element>sup</element>
	  <element>unit_number</element>
	  <element>unit</element>
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry>
    <xpath>//unit_number</xpath>
    <children>
      <element>number</element>
      <element>unit</element>
    </children>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
return self.text
    </conversion-callback>
  </entry>

  <!-- //currency/number shadows //number -->
  <entry>
    <xpath>//currency/number</xpath>
    <validation-callback>is_float</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//number</xpath>
    <children>
      <subset-of>
	<element>coeff</element>
	<element>base</element>
	<element>exp</element>
      </subset-of>
    </children>
    <validation-callback>is_number</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
if len(self) == 0:
    if 'e' in self.text:
        # Number in exponential notation: convert to coeff and exp
        numberText = self.text.strip()
        self.text = None
        self.append(etree.Element('coeff'))
        pos = numberText.find('e')
        self[-1].text = numberText[:pos]
        self.append(etree.Element('exp'))
        self[-1].text = str(int(numberText[pos+1:]))
    else:
        # No children, means it's just a plain number
        numberText = self.text.strip()
        self.text = None
        self.append(etree.Element('coeff'))
        self[-1].text = numberText

# Parse out coefficient, base and exponent
nodes = {}
text = {}
for key in ['coeff', 'exp', 'base']:
    nodes[key] = self.find(key)
    text[key] = nodes[key].text.strip() if nodes[key] is not None else None
if text['base'] is None:
    text['base'] = '10'
for key in text:
    if text[key] is None: continue
    if text[key][0] == '-':
        minus = '-'
        text[key] = text[key][1:]
    else:
        minus = ''
    text[key] = minus + r'\text{' + utils.format_number(text[key], thousandsSeparator=r'\ ') + '}'

# Build LaTeX representation
result = text['coeff'] if nodes['coeff'] is not None else ''
if nodes['exp'] is not None:
    if nodes['coeff'] is not None:
        result += r' \times '
    result += text['base'] + '^{' + text['exp'] + '}'

# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'

return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//number/coeff</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//number/base</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//number/exp</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//unit</xpath>
    <children>
      <any-number>
	<element>sup</element>
      </any-number>
    </children>
    <validation-callback>is_unit</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
unitsWithoutSpace = [u'°']
inUnitNumber = (self.getparent().tag == 'unit_number')
result = r'\text{' + self.text + '}'
# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'
    if inUnitNumber and (self.text[0] not in unitsWithoutSpace):
        result = '~' + result
else:
    if inUnitNumber and (self.text[0] not in unitsWithoutSpace):
        assert result[:6] == r'\text{', "Weird error in //unit conversion."
        result = result[:6] + ' ' + result[6:]
return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//unit/sup</xpath>
    <validation-callback>is_number</validation-callback>
    <conversion-callback name="latex learner correct teacher">
return '$^{' + self.text + '}$'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
parents = [a.tag for a in self.iterancestors()]
if 'latex' in parents:
    return '^{%s}'%self.text
else:
    sup = etree.Element('sup')
    sup.text = self.text
    return etree.tostring(sup)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//percentage</xpath>
    <validation-callback>is_float</validation-callback>
    <conversion-callback name="latex learner correct teacher">
return convert_using(self, '//number') + r'\%'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return convert_using(self, '//number') + r'%'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//currency</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>precision</name>
	<type>integer</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <unordered>
	<optional>symbol</optional>
	<element>number</element>
      </unordered>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
numberText = self.find('number').text.strip()
try:
    int(numberText.strip())
    defaultPrecision = 0
except ValueError:
    defaultPrecision = 2
currencyPrecision = int(self.attrib.get('precision', defaultPrecision))
numberText = ("%%.%if"%currencyPrecision)%float(numberText)
numberText = utils.format_number(numberText, thousandsSeparator=r'\ ')

symbolNode = self.find('symbol')
if symbolNode is None:
    symbol = 'R'
    symbolLocation = 'front'
else:
    symbol = symbolNode.text.strip()
    symbolLocation = symbolNode.attrib.get('location', 'front')



if symbolLocation == 'front':
    result = symbol + r'\ ' + numberText
else:
    result = numberText + r'\ ' + symbol
result = r'\text{' + result + '}'

# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'

return result
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
numberText = self.find('number').text.strip()
try:
    int(numberText.strip())
    defaultPrecision = 0
except ValueError:
    defaultPrecision = 2
currencyPrecision = int(self.attrib.get('precision', defaultPrecision))
numberText = ("%%.%if"%currencyPrecision)%float(numberText)
numberText = utils.format_number(numberText, thousandsSeparator=r' ')

symbolNode = self.find('symbol')
if symbolNode is None:
    symbol = 'R'
    symbolLocation = 'front'
else:
    symbol = symbolNode.text.strip()
    symbolLocation = symbolNode.attrib.get('location', 'front')



if symbolLocation == 'front':
    result = symbol + r' ' + numberText
else:
    result = numberText + r' ' + symbol
result = r'\text{' + result + '}'

# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'

return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//currency/symbol</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>location</name>
	<type>enum("front","back")</type>
	<default>front</default>
      </entry>
    </attributes>
  </entry>

  <entry>
    <xpath>//chem_compound</xpath>
    <conversion-callback name="latex html learner correct teacher">
text = self.text.strip()
pos = 0
while pos &lt; len(text):
    if text[pos].isalpha():
        start = pos
        pos += 1
        while (pos &lt; len(text)) and text[pos].isalpha():
            pos += 1
        text = text[:start] + r'\text{' + text[start:pos] + '}' + text[pos:]
        pos += 7
    else:
        pos += 1
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    text = r'\(' + text + r'\)'
return text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//spec_note</xpath>
    <conversion-callback name="latex html learner correct teacher">
return convert_using(self, '//chem_compound')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//nuclear_notation</xpath>
    <children>
      <unordered>
	<element>symbol</element>
	<element>mass_number</element>
	<element>atomic_number</element>
      </unordered>
    </children>
    <notext/>
    <validation-callback>is_nuclear_notation</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
latex = r'_{%s}^{%s}\text{%s}'%(self.find('atomic_number').text, self.find('mass_number').text, self.find('symbol').text)
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    latex = r'\(' + latex + r'\)'
return latex
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//nuclear_notation/symbol</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//nuclear_notation/mass_number</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//nuclear_notation/atomic_number</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>//br</xpath>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
return r'\\'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return '\n'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//space</xpath>
    <notext/>
    <attributes>
        <entry>
            <name>count</name>
            <type>string</type>
        </entry>
        <entry>
            <name>effect</name>
            <type>string</type>
        </entry>
    </attributes>
    <conversion-callback name="latex learner correct teacher">
if self.attrib['effect'] == 'underline':
    return r'\underline{\hspace{%sem}}' % self.attrib['count']
else:
    return r'\hspace{%sem}' % self.attrib['count']
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
    return r'_'*int(self.attrib['count'])
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//newline</xpath>
    <notext/>
    <attributes>
        <entry>
            <name>count</name>
            <type>string</type>
            <default/>
        </entry>
        <entry>
            <name>effect</name>
            <type>string</type>
            <default/>
        </entry>
    </attributes>
    <conversion-callback name="latex learner correct teacher">
if 'effect' in self.attrib.keys():
    if self.attrib['effect'] == 'underline':
        return r'\answerline{%s}' % self.attrib['count']
    elif self.attrib['effect'] == 'normal':
        return r'\answerspace{%s}' % self.attrib['count']
else:
    return r''
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
if 'effect' in self.attrib.keys():
    if self.attrib['effect'] == 'underline':
        return r'&lt;hr/&gt;'*int(self.attrib['count'])
    elif self.attrib['effect'] == 'normal':
        return r'&lt;br/&gt;'*int(self.attrib['count'])
else:
    return r''
    </conversion-callback>
  </entry>


  <entry>
    <xpath>//emphasis</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>effect</name>
	<type>enum("bold","italics","underline","smallcaps","normal")</type>
	<default>bold</default>
      </entry>
    </attributes>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
pattern = {
    'bold': r'\textbf{%s}',
    'italics': r'\textit{%s}',
    'underline': r'\underline{%s}',
    'smallcaps': r'\textsc{%s}',
    'normal': '%s',
}[self.attrib['effect']]
return pattern%self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
#pattern = {
#    'bold': r'\(\textbf{%s}\)',
#    'italics': r'\(\textit{%s}\)',
#    'underline': r'\(\underline{%s}\)',
#    'smallcaps': r'\(\textsc{%s}\)',
#    'normal': '%s',
#}[self.attrib['effect']]

if self.attrib['effect'] == 'bold':
    emph = etree.Element('strong')

elif self.attrib['effect'] == 'italics':
    emph = etree.Element('em')

elif self.attrib['effect'] == 'underline':
    emph = etree.Element('u')

elif self.attrib['effect'] == 'smallcaps':
    emph = etree.Element('span')
    emph.attrib['data-class'] = 'smallcaps'

elif self.attrib['effect'] == 'normal':
    emph = etree.Element('span')
    emph.attrib['data-class'] = 'normal'

emph.text = self.text
return etree.tostring(emph)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//nth</xpath>
    <attributes>
      <entry>
	<name>format</name>
	<type>enum("word","superscript")</type>
	<default>word</default>
      </entry>
    </attributes>
    <conversion-callback name="latex html learner correct teacher">
try:
    value = int(self.text)
    isInt = True
except ValueError:
    value = self.text.strip()
    isInt = False

format = self.attrib['format']
if (format == 'word') and isInt and (value &lt; 12):
    return ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'eleventh'][value-1]
else:
    # format == 'superscript'
    if isInt:
        if (value % 10 == 1) and (value//10 % 10 != 1):
            suffix = 'st'
        elif (value % 10 == 2) and (value//10 % 10 != 1):
            suffix = 'nd'
        elif (value % 10 == 3) and (value//10 % 10 != 1):
            suffix = 'rd'
        else:
            suffix = 'th'
        value = str(value)
    else:
        suffix = 'th'
    return r'\(' + value + r'^{\text{' + suffix + r'}}\)'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//link</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>url</name>
	<type>url</type>
	<default/>
      </entry>
      <entry>
	<name>target-id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>window</name>
	<type>string</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <reference>inline-element</reference>
    </children>
    <validation-callback>check_link_element</validation-callback>
    <conversion-callback name="latex learner correct teacher">
target = self.attrib.get('target-id')
if target is not None:
    return r'\REF{' + target + '}'
url = self.attrib.get('url')
if url is not None:
    if self.text != '':
        return r'\HREF{' + escape_latex(url) + '}{' + escape_latex(self.text) + '}'
    else:
        return r'\URL{' + escape_latex(url) + '}'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
target = self.attrib.get('target-id')
link = etree.Element('a')
if target is not None:
    link.attrib['href'] = '#'+target
    link.text = target
    link.attrib['data-class'] = 'InternalLink'
    return etree.tostring(link)
url = self.attrib.get('url')
if url is not None:
    link.attrib['data-class'] = 'ExternalLink'
    if self.text != '':
        link.text = self.text
        link.attrib['href'] = url
        return etree.tostring(link)
    else:
        link.text = self.text
        link.attrib['href'] = url
        return etree.tostring(link)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//sub</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
return r'$_{\text{%s}}$'%self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return self
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//sup</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
return r'$^{\text{%s}}$'%self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return self
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//sup</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="html latex learner correct teacher">
return etree.tostring(self)
    </conversion-callback>
  </entry>
    
  <entry>
    <xpath>//html5table</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <optional>thead</optional>
      <optional>tfoot</optional>
      <optional>tbody</optional>
      <optional>caption</optional>
      <any-number>
	<optional>tr</optional>
      </any-number>
    </children>
    <conversion-callback name="latex learner correct teacher">
      return "%HTML5 Table TODO
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
self.tag = 'table'
return etree.tostring(self, pretty_print=True)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//html5table/caption</xpath>
    <conversion-callback name="html learner correct teacher">
return
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//html5table/thead</xpath>
    <children>
      <optional>tr</optional>
      <optional>th</optional>
    </children>
  </entry>

  <entry>
    <xpath>//tr</xpath>
    <children>
      <any-number>
	<optional>th</optional>
	<optional>td</optional>
      </any-number>
    </children>
  </entry>

  <entry>
    <xpath>//tr/th</xpath>
  </entry>

  <entry>
    <xpath>//tr/td</xpath>
  </entry>

  <entry>
    <xpath>//html5table/tbody</xpath>
    <children>
      <any-number>
	<optional>tr</optional>
	<optional>th</optional>
      </any-number>
    </children>
  </entry>

  <entry>
    <xpath>//html5table/tfoot</xpath>
    <children>
      <any-number>
	<optional>tr</optional>
	<optional>th</optional>
      </any-number>
    </children>
  </entry>

  <entry>
    <xpath>//html5table/tr/th</xpath>
  </entry>

  <entry>
    <xpath>//html5table/tr/td</xpath>
  </entry>

  <entry>
    <xpath>//html5table/tr</xpath>
    <children>
      <one-of>
	<optional>thead</optional>
	<optional>tbody</optional>
	<optional>tfoot</optional>
      </one-of>
      <any-number>
	<optional>th</optional>
	<optional>td</optional>
      </any-number>
    </children>
    <conversion-callback name="html learner correct teacher">
return
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//html5table/th</xpath>
  </entry>

</spec>
