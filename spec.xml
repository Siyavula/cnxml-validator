<?xml version="1.0" encoding="utf-8"?>
<spec xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:style="http://siyavula.com/cnxml/style/0.1" xmlns:its="http://www.w3.org/2005/11/its">
  <entry>
    <xpath>/document</xpath>
    <children>
      <optional>its:rules</optional>
      <optional>metadata</optional><!-- occurs 0 or 1 times -->
      <element>content</element><!-- occurs exactly once -->
    </children>
    <notext/>
    <documentation>
The document element is the root.
It may have a metadata element and must have a content element.
    </documentation>
    <conversion-callback name="latex html learner correct teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/metadata</xpath>
    <children>
      <subset-of><!-- subsetsof: at most one of each in the set; unordered -->
	<element>cnxml-version</element>
	<element>pspicture-generator-version</element>
      </subset-of>
    </children>
    <notext/>
    <documentation>
The metadata section contains information about the XML document itself.
Only version numbers at this time.
You must not edit this section manually, unless you really know what you're doing.
    </documentation>
    <conversion-callback name="latex html learner correct teacher">
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/metadata/cnxml-version</xpath>
    <text>
      <pre-processing-callback>strip</pre-processing-callback>
    </text>
    <validation-callback>is_version_number</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/metadata/pspicture-generator-version</xpath>
    <text>
      <pre-processing-callback>strip</pre-processing-callback>
    </text>
    <validation-callback>is_version_number</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content</xpath>
    <children>
      <one-of>
	<any-number>
	  <element>section</element>
	</any-number>
	<reference>block-element</reference>
      </one-of>
    </children>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
return self.text.strip()
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//activity/section</xpath>
    <children>
      <element>title</element>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'ActivitySection'
return '\n\\begin{' + environment + '}{' + self.attrib['title'] + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
activitysection = etree.Element('div')
activitysection.attrib['class'] = 'section'
activitysection.text = self.text
activitysection.tail = '\n'
return etree.tostring(activitysection)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//activity/section/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner teacher">
self.getparent().attrib['title'] = self.text.strip()
return ''
    </conversion-callback>
    <conversion-callback name="html learner teacher">
title = etree.Element('h1')
title.attrib['class'] = 'title'
title.text = self.text.strip()
self.getparent().attrib['title'] = self.text.strip()
return etree.tostring(title)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//section</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>type</name>
	<type>enum("chapter","section","subsection","subsubsection","subsubsubsection")</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <element>title</element>
      <optional>shortcode</optional><!--TODO: this should be required-->
      <reference>block-element</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
result = self.text.strip()
if self.attrib.get('shortcode') is not None:
    result = '\n' + r'\setsectionshortcode{' + self.attrib['shortcode'] + '}\n' + result
return result
    </conversion-callback>
    <conversion-callback name="html learner teacher">
result = self.text.strip()
newElement = etree.Element('div')
newElement.attrib['class'] = 'section'
newElement.attrib['class'] = 'section'
newElement.text = result
if self.attrib.get('shortcode') is not None:
    newElement.attrib['id'] = 'sc%s'%self.attrib.get('shortcode')
return etree.tostring(newElement)
    </conversion-callback>
    <conversion-callback name="latex html correct">
return self.text.strip()
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//teachers-guide</xpath>
    <children>
      <reference>block-element</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher correct">
environment = "TeachersGuide"
return '\n\\begin{' + environment + '}\n' + self.text.strip() + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html teacher learner correct">
tg = etree.Element('div')
tg.attrib['class'] = 'teachers-guide'
tg.text = self.text
return etree.tostring(tg)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//section/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner teacher">
level = -1
node = self.getparent()
while node is not None:
    if node.tag == 'section':
        level += 1
    node = node.getparent()
sections = ['chapter', 'section', 'subsection', 'subsubsection', 'paragraph']
if level >= len(sections):
    warning_message("Exceeded maximum section level (title: %s)"%(repr(self.text)))
    section = sections[-1]
else:
    section = sections[level]
return '\\%s{%s}\n'%(section, self.text)
    </conversion-callback>
    <conversion-callback name="latex correct">
level = -1
node = self.getparent()
while node is not None:
    if node.tag == 'section':
        level += 1
    node = node.getparent()
if level == 0:
    return '\\SolutionsChapter{%s}\n'%(self.text)
else:
    return ''
    </conversion-callback>
    <conversion-callback name="html learner teacher">
level = -1
node = self.getparent()
while node is not None:
    if node.tag == 'section':
        level += 1
    node = node.getparent()
sections = ['chapter', 'section', 'subsection', 'subsubsection', 'paragraph']
headinglevels = ['h1', 'h2', 'h3', 'h4', 'h5']
if level >= len(sections):
    warning_message("Exceeded maximum section level (title: %s)"%(repr(self.text)))
    section = sections[-1]
else:
    section = sections[level]
    headlevel = headinglevels[level]

newElement = etree.Element(headlevel)
newElement.attrib['class'] = 'title'
newElement.attrib['class'] = 'title'
newElement.text = self.text

return etree.tostring(newElement)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//section/shortcode</xpath>
    <validation-callback>is_section_shortcode</validation-callback>
    <conversion-callback name="html latex learner correct teacher">
self.getparent().attrib['shortcode'] = self.text
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//para</xpath>
    <children>
      <reference>inline-container-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
text = ' '.join(self.text.strip().split())
pos = text.find('"')
if pos != -1:
    warning_message('Straight double quote in text, consider replacing with left/right quotes: %s'%repr(text[pos-20:pos+20]))
# check if para doesn't only contain a \\
if text.strip() == r'\\':
    text = text.replace(r'\\', r'')
return '\\par\n' + text + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
text = ' '.join(self.text.strip().split())
newElement = etree.Element('p')
newElement.text = self.text.strip()
return '\n' + etree.tostring(newElement) + '\n'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//list</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>list-type</name>
	<type>enum("bulleted","enumerated")</type>
	<default>bulleted</default>
      </entry>
      <entry>
	<name>bullet-style</name>
	<type>enum("bullet", "open-circle", "pilcrow", "rpilcrow", "asterisk", "dash", "section", "none")</type>
	<default>bullet</default>
      </entry>
      <entry>
	<name>start-value</name>
	<type>integer(1,)</type>
	<default>1</default>
      </entry>
      <entry>
	<name>mark-prefix</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>number-style</name>
	<type>enum("arabic","upper-alpha","lower-alpha","upper-roman","lower-roman")</type>
	<default>arabic</default>
      </entry>
      <entry>
	<name>bullet-style</name>
	<type>enum("bullet","open-circle")</type>
	<default>bullet</default>
      </entry>
    </attributes>
    <children>
      <any-number from="1">
	<element>item</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
listType = self.attrib['list-type']
if listType == 'bulleted':
    environment = 'ListBulleted'
elif listType == 'enumerated':
    environment = 'ListEnumerated'
startval = self.attrib.get('start-value')
if startval == '1':
    startval = ''
else:
    startval = r'\setcounter{enumi}{%s}' % str(int(startval)-1)

return '\n\\begin{' + environment + '}\n%s' % startval + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
listType = self.attrib['list-type']
if listType == 'bulleted':
    environment = 'ListBulleted'
    newlist = etree.Element('ul')
elif listType == 'enumerated':
    environment = 'ListEnumerated'
    newlist = etree.Element('ol')

newlist.text = self.text
newlist.attrib['data-class'] = environment

return etree.tostring(newlist)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//list/item</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner correct teacher">
return r'\item ' + self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
newitem = etree.Element('li')
newitem.text = self.text
newitem.tail = '\n'
return etree.tostring(newitem)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//table</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>frame</name>
	<type>enum("none",)</type>
	<default/>
      </entry>
      <entry>
	<name>colsep</name>
	<type>integer</type>
	<default/>
      </entry>
      <entry>
	<name>rowsep</name>
	<type>integer</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <element>tgroup</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
tabularNewline = r'\tabularnewline'
columnAlignment = eval(self.attrib['latexColumnAlignment'])
return r'\par'+'\n'+r'\begin{Table}{|' + '|'.join(columnAlignment) + '|}\n' + self.text + tabularNewline + '\n' + r'\hline' + '\n' + r'\end{Table}' + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
table = etree.Element('table')
# if the next tag is caption, add it as table summary text.
if self.getnext() is not None:
    if self.getnext().tag == 'caption':
        table.attrib['summary'] = self.getnext().text
table.text = self.text
return etree.tostring(table)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//table/tgroup</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>cols</name>
	<type>integer(1,)</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <any-number from="1">
	<element>colspec</element>
      </any-number>
      <element>tbody</element>
    </children>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
cols = self.attrib.get('cols')
if cols is not None:
    if self.attrib.get('columnCount') is not None:
        assert self.attrib.get('columnCount') == cols, "Table column count specified in 'cols' attribute does not match number of columns in colspec."
    else:
        self.attrib['columnCount'] = cols
parentAttrib = self.getparent().attrib
parentAttrib['columnCount'] = self.attrib['columnCount']
parentAttrib['latexColumnAlignment'] = self.attrib['latexColumnAlignment']
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//table/tgroup/colspec</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>colname</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>colnum</name>
	<type>integer(1,)</type>
      </entry>
      <entry>
	<name>colwidth</name>
	<type>string</type> <!-- 475.4 -->
	<default/>
      </entry>
      <entry>
	<name>style:latex-alignment</name>
	<type>string</type>
	<default/> <!-- default: c -->
      </entry>
    </attributes>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
parentAttrib = self.getparent().attrib
parentAttrib['columnCount'] = str(int(parentAttrib.get('columnCount', '0')) + 1)
columnSpec = eval(parentAttrib.get('columnSpec', '{}'))
columnSpec[self.attrib.get('colname')] = int(self.attrib['colnum'])-1
parentAttrib['columnSpec'] = repr(columnSpec)

latexAlignmentKey = '{http://siyavula.com/cnxml/style/0.1}latex-alignment'
if parentAttrib.get('latexColumnAlignment') is None:
    parentAttrib['latexColumnAlignment'] = '[]'
if self.attrib.get(latexAlignmentKey) is None:
    colwidth = self.attrib.get('colwidth')
    if colwidth is not None:
        # Set LaTeX column width based on colwidth attribute
        try:
            assert colwidth[-2:] == 'pt'
        except AssertionError:
            # hack in a default value
            colwidth = '150pt'
        colwidth = float(colwidth[:-2])
        relativeWidth = colwidth / 480
        self.attrib[latexAlignmentKey] = r'&gt;{\centering}p{%.6f\textwidth}'%(0.85*relativeWidth)
    else:
        # Set default value
        self.attrib[latexAlignmentKey] = 'c'
parentAttrib['latexColumnAlignment'] = repr(eval(parentAttrib['latexColumnAlignment']) + [self.attrib[latexAlignmentKey]])

return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//table/tgroup/tbody</xpath>
    <children>
      <any-number>
	<element>row</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
tabularNewline = r'\tabularnewline'
text = self.text.strip()
assert text[-len(tabularNewline):] == tabularNewline, "Weird latex table error in /document/content//table/tgroup/tbody conversion."
return text[:-len(tabularNewline)] + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
    return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//table/tgroup/tbody/row</xpath>
    <children>
      <any-number>
	<element>entry</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
tabularNewline = r'\tabularnewline'
text = self.text.strip()
assert text[-1] == '&amp;', "Weird latex table error in /document/content//table/tgroup/tbody/row conversion."
return '\\hline\n' + text[:-1] + tabularNewline + '\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
row = etree.Element('tr')
row.text = self.text
return etree.tostring(row)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//table/tgroup/tbody/row/entry</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>namest</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>nameend</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>align</name>
	<type>enum("center",)</type>
	<default/>
      </entry>
      <entry>
	<name>morerows</name>
	<type>integer</type>
	<default>0</default>
      </entry>
    </attributes>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner correct teacher">
multiColumnStart = self.attrib.get('namest')
multiColumnEnd = self.attrib.get('nameend')
moreRows = int(self.attrib['morerows'])
if (multiColumnStart is not None) and (multiColumnEnd is not None):
    if moreRows &gt; 0:
        error_message('Cannot handle table entries that span multiple rows and columns')
    columnSpec = eval(self.getparent().getparent().getparent().attrib.get('columnSpec'))
    columnCount = columnSpec[multiColumnEnd] - columnSpec[multiColumnStart] + 1
else:
    columnCount = 1
if columnCount &gt; 1:
    return r'\multicolumn{' + str(columnCount) + r'}{|c|}{' + self.text.strip() + r'} &amp;'
else:
    if moreRows &gt; 0:
        text = self.text.strip()
        while text[:4] == r'\par':
            text = text[4:].lstrip()
        while text[-4:] == r'\par':
            text = text[:-4].rstrip()
        return r'\multirow{' + str(moreRows+1) + '}{*}{' + text + r'} &amp;'
    else:
        return self.text.strip() + ' &amp;'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
td = etree.Element('td')
multiColumnStart = self.attrib.get('namest')
multiColumnEnd = self.attrib.get('nameend')
moreRows = int(self.attrib['morerows'])
if (multiColumnStart is not None) and (multiColumnEnd is not None):
    if moreRows &gt; 0:
        error_message('Cannot handle table entries that span multiple rows and columns')
    columnSpec = eval(self.getparent().getparent().getparent().attrib.get('columnSpec'))
    columnCount = columnSpec[multiColumnEnd] - columnSpec[multiColumnStart] + 1
else:
    columnCount = 1
if columnCount &gt; 1:
    td.text = self.text.strip()
    td.attrib['colspan'] = str(columnCount)
    return etree.tostring(td)
else:
    if moreRows &gt; 0:
        text = self.text.strip()
        while text[:4] == r'\par':
            text = text[4:].lstrip()
        while text[-4:] == r'\par':
            text = text[:-4].rstrip()
        td.text = text
        td.attrib['rowspan'] = str(moreRows+1)
        return etree.tostring(td)
    else:
        td.text = self.text.strip()
        return etree.tostring(td)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises</xpath>
    <children>
      <optional>title</optional>
      <element>problem-set</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'Exercises'

# Shortcodes
shortcodeColumns = 6
numbering = [
    lambda index: '',
    lambda index: str(index),
    lambda index: chr(ord('a') + index - 1),
    lambda index: ['i','ii','iii','iv','v','vi','vii','viii','ix','x'][index-1],
]
shortcodes = eval(self.attrib.get('shortcodes'))
shortcodeStack = [(0, '', 1, shortcodes)] # (depth, numbering prefix, numbering index, shortcodes)
shortcodeArray = []
while len(shortcodeStack) > 0:
    depth, shortcodePrefix, shortcodeIndex, shortcodeEntry = shortcodeStack.pop()
    shortcodePrefix += numbering[depth](shortcodeIndex)
    if isinstance(shortcodeEntry, dict):
        keys = shortcodeEntry.keys()
	for key in sorted(keys, reverse=True):
            shortcodeStack.append((depth+1, shortcodePrefix, key, shortcodeEntry[key]))
    else:
        shortcodeArray.append((shortcodePrefix, shortcodeEntry))
shortcodeLatex = ''
if len(shortcodeArray) > 0:
    shortcodeLatex += r'\begin{ExercisesShortcodes}' + '\n' + r'\begin{tabular}{' + 'r@{ }l'*shortcodeColumns + '}\n'
    while True:
        row = [entry[0] + r'. &amp; \shortcode{' + entry[1] + '}' for entry in shortcodeArray[:shortcodeColumns]]
        shortcodeArray = shortcodeArray[shortcodeColumns:]
        shortcodeLatex += ' &amp; '.join(row)
        if len(shortcodeArray) == 0:
            break
        shortcodeLatex += r'\\' + '\n'
    shortcodeLatex += '\n' + r'\end{tabular}' + '\n' + r'\end{ExercisesShortcodes}' + '\n'

return '\n\\begin{' + environment + '}{' + self.attrib.get('title', '') + '}\n' + self.text + shortcodeLatex + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = etree.Element('div')
environment.attrib['class'] = 'exercises'
environment.text = self.text
environment.tail = '\n'

return etree.tostring(environment)
    </conversion-callback>
    <conversion-callback name="latex correct">
environment = 'Exercises'
columnCount = 2
return '\n\\begin{' + environment + '}{' + self.attrib.get('title', '') + '}\n' + r'\begin{ExercisesProblemsetColumns}{' + str(columnCount) + '}\n' + self.text + r'\end{ExercisesProblemsetColumns}' + '\n' + r'\end{' + environment + '}\n'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
self.getparent().attrib['title'] = self.text.strip()
return ''
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
title = etree.Element('h1')
title.text = self.text.strip()
if title.text == '': title.text = ' '
title.attrib['class'] = 'title'

return etree.tostring(title)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set</xpath>
    <attributes>
      <entry>
	<name>style:columns</name>
	<type>integer(1,)</type>
	<default>1</default>
      </entry>
    </attributes>
    <children>
      <optional>header</optional>
      <any-number>
	<one-of>
	  <element>problem-set</element>
	  <element>multi-part</element>
	  <element>entry</element>
	  <!--<element>monassis-template</element>-->
	</one-of>
      </any-number>
      <optional>footer</optional>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
# Store shortcode in problem-set
if self.tag == 'problem-set': # multi-part also uses this transform, guard against it for shortcodes
    parentTag = self.getparent().tag
    assert parentTag in ['exercises', 'problem-set'], "&lt;problem-set&gt; should only every be a child of &lt;exercises&gt; or &lt;problem-set&gt;, got &lt;%s&gt; instead."%parentTag
    if parentTag == 'exercises':
        # This is the top-level problem-set
        self.getparent().attrib['shortcodes'] = self.attrib.get('shortcodes', '{}')
    else:
        myShortcodesRepr = self.attrib.get('shortcodes')
        if myShortcodesRepr is not None:
            count = int(self.getparent().attrib.get('problem-set-entry-count', 0)) + 1
            parentShortcodes = eval(self.getparent().attrib.get('shortcodes', '{}'))
            parentShortcodes[count] = eval(myShortcodesRepr)
            self.getparent().attrib['shortcodes'] = repr(parentShortcodes)

problemsetEnvironment = 'ExercisesProblemset'
#entryEnvironment = 'ExercisesProblemsetEntry' # HACK to solve number scrunching problem
entriesEnvironment = 'enumerate' # 'ExercisesProblemsetEntries' # HACK to solve number scrunching problem
if self.getparent().tag == 'exercises':
    # First level of numbering in exercise environment
    return '\n\\begin{' + problemsetEnvironment + '}\n' + self.text + r'\end{' + problemsetEnvironment + '}\n'
else:
    columnCount = int(self.getparent().attrib['{http://siyavula.com/cnxml/style/0.1}columns'])
    if columnCount > 1:
        columnsBegin = r'\begin{ExercisesProblemsetColumns}{' + str(columnCount) + '}\n'
        columnsEnd = '\\end{ExercisesProblemsetColumns}\n'
    else:
        columnsBegin = ''
        columnsEnd = ''

    count = int(self.getparent().attrib.get('problem-set-entry-count', 0)) + 1
    self.getparent().attrib['problem-set-entry-count'] = str(count)
    if count == 1:
        # First entry in problem set
        result = '\n' + columnsBegin + r'\begin{' + entriesEnvironment + '}'
    else:
        result = ''

    # HACK to solve number scrunching problem
    # result += '\n\\begin{' + entryEnvironment + '}\n\\begin{' + problemsetEnvironment + '}\n' + self.text + r'\end{' + problemsetEnvironment + '}\n' + r'\end{' + entryEnvironment + '}\n'
    result += '\n\\item\n\\begin{' + problemsetEnvironment + '}\n' + self.text + r'\end{' + problemsetEnvironment + '}\n'

    if (self.getnext() is None) or (self.getnext().tag == 'footer'):
        # Last entry in problem set
        result += '\n' + r'\end{' + entriesEnvironment + '}\n' + columnsEnd

    return result
    </conversion-callback>
    <conversion-callback name="html learner teacher">
problemset = etree.Element('div')
problemset.attrib['class'] = 'problemset'
problemset.text = self.text

return etree.tostring(problemset)
    </conversion-callback>
    <conversion-callback name="latex correct">
entriesEnvironment = 'enumerate' # 'ExercisesProblemsetEntries' # HACK to solve number scrunching problem
if self.getparent().tag == 'exercises':
    # First level of numbering in exercise environment
    # Check if my sub-list had all its entries skipped
    if self.text.count(r'\item') == 0:
        return ''
    else:
        return self.text
else:
    count = int(self.getparent().attrib.get('problem-set-entry-count', 0)) + 1
    self.getparent().attrib['problem-set-entry-count'] = str(count)
    if count == 1:
        # First entry in problem set
        result = '\n' + r'\begin{' + entriesEnvironment + '}'
    else:
        result = ''

    # Check if my sub-list had all its entries skipped
    if self.text.count(r'\item') == 0:
        depth = 0
        node = self.getparent()
        while node.tag in ['problem-set', 'multi-part']:
            depth += 1
            node = node.getparent()
        result += r'\stepcounter{enum' + 'i'*depth + '}\n'
    else:
        result += '\n\\item\n' + self.text

    if self.getnext() is None:
        # Last entry in problem set
        result += '\n' + r'\end{' + entriesEnvironment + '}\n'

    return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/header</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'ExercisesProblemsetHeader'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'header'
header = etree.Element('div')
header.attrib['class'] = environment
header.text = self.text
return etree.tostring(header)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/footer</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'ExercisesProblemsetFooter'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'header'
footer = etree.Element('div')
footer.attrib['class'] = environment
return etree.tostring(footer)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/entry</xpath>
    <children>
      <any-number from="0"><!-- FIXME: This is a hack since multiple shortcodes have to point to the same thing in some exercises. This needs to become stricter since we cannot render multiple shortcodes in the book for one exercises. -->
	<element>shortcode</element>
      </any-number>
      <element>problem</element>
      <element>solution</element>
      <optional>correct</optional>
    </children>
    <notext/>
    <validation-callback>problemset_entry_contains_correct_and_shortcode</validation-callback>
    <conversion-callback name="latex learner teacher">
problemsetEnvironment = 'ExercisesProblemset'
#entryEnvironment = 'ExercisesProblemsetEntry' # HACK to solve number scrunching problem
entriesEnvironment = 'enumerate' # 'ExercisesProblemsetEntries' # HACK to solve number scrunching problem

columnCount = int(self.getparent().attrib['{http://siyavula.com/cnxml/style/0.1}columns'])
if columnCount > 1:
    columnsBegin = r'\begin{ExercisesProblemsetColumns}{' + str(columnCount) + '}\n'
    columnsEnd = '\\end{ExercisesProblemsetColumns}\n'
else:
    columnsBegin = ''
    columnsEnd = ''

count = int(self.getparent().attrib.get('problem-set-entry-count', 0)) + 1
self.getparent().attrib['problem-set-entry-count'] = str(count)
if count == 1:
    # First entry in problem set
    result = '\n' + columnsBegin + r'\begin{' + entriesEnvironment + '}'
else:
    result = ''

# HACK to solve number scrunching problem
#result += '\n\\begin{' + entryEnvironment + '}\n' + self.text + r'\end{' + entryEnvironment + '}'
result += '\n\item ' + self.text

if (self.getnext() is None) or (self.getnext().tag == 'footer'):
    # Last entry in problem set
    result += '\n' + r'\end{' + entriesEnvironment + '}\n' + columnsEnd
return result
    </conversion-callback>
    <conversion-callback name="html learner teacher">
problemsetEnvironment = 'entry'
problemset = etree.Element('div')
problemset.attrib['class'] = problemsetEnvironment
problemset.text = self.text

return etree.tostring(problemset)
    </conversion-callback>
    <conversion-callback name="latex correct">
entriesEnvironment = 'enumerate' # 'ExercisesProblemsetEntries' # HACK to solve number scrunching problem
count = int(self.getparent().attrib.get('problem-set-entry-count', 0)) + 1
self.getparent().attrib['problem-set-entry-count'] = str(count)
if count == 1:
    # First entry in problem set
    result = '\n' + r'\begin{' + entriesEnvironment + '}'
else:
    result = ''

if self.text.strip() == '':
    depth = 0
    node = self.getparent()
    while node.tag in ['problem-set', 'multi-part']:
        depth += 1
        node = node.getparent()
    result += r'\stepcounter{enum' + 'i'*depth + '}\n'
else:
    result += '\n\item ' + self.text

if self.getnext() is None:
    # Last entry in problem set
    result += '\n' + r'\end{' + entriesEnvironment + '}\n'
return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/entry/shortcode</xpath>
    <validation-callback>is_exercise_shortcode</validation-callback>
    <conversion-callback name="html latex learner teacher">
# Store shortcode in problem-set
count = int(self.getparent().getparent().attrib.get('problem-set-entry-count', 0)) + 1
shortcodes = eval(self.getparent().getparent().attrib.get('shortcodes', '{}'))
shortcodes[count] = self.text
self.getparent().getparent().attrib['shortcodes'] = repr(shortcodes)
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/entry/problem</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner teacher">
environment = 'ExercisesProblemsetEntryProblem'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'problem'
problem = etree.Element('div')
problem.attrib['class'] = environment
problem.text = self.text
return etree.tostring(problem)
    </conversion-callback>
    <conversion-callback name="latex correct">
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/entry/solution</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>url</name>
	<type>url</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner teacher">
if self.text.strip() == '':
    warning_message("Empty solution.")

renderSolutions = True # Put full solutions in textbook?

if renderSolutions:
    environment = 'ExercisesProblemsetEntrySolution'
    return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
else:
    return ''
    </conversion-callback>
    <conversion-callback name="html learner teacher">
if self.text.strip() == '':
    warning_message("Empty solution.")

renderSolutions = True # Put full solutions in textbook?

if renderSolutions:
    environment = 'solution'
    solution = etree.Element('div')
    solution.attrib['class'] = environment
    solution.text = self.text
    return etree.tostring(solution)
else:
    return ''
    </conversion-callback>
    <conversion-callback name="latex correct">
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/entry/correct</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="html latex correct">
return '\n' + self.text.strip() + '\n'
    </conversion-callback>
    <conversion-callback name="html latex learner teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//definition</xpath>
    <children>
      <element>term</element>
      <element>meaning</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher"><!-- type already creates start of environment -->
environment = 'Definition'
return '\n\\begin{' + environment + '}{' + self.attrib['title'] + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher"><!-- type already creates start of environment -->
environment = 'definition'
definition = etree.Element('dl')
definition.attrib['class'] = environment
term = etree.Element('dt')
meaning = etree.Element('dd')
term.text = self.attrib['title']
meaning.text = self.text
definition.append(term)
definition.append(meaning)
return etree.tostring(definition)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//definition/term</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//definition/meaning</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html learner teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//theorem</xpath>
    <children>
      <optional>label</optional>
      <optional>title</optional>
      <element>statement</element>
      <element>given</element>
      <element>required</element>
      <element>proof</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'Theorem'
return r'''
\begin{''' + environment + '}{' + self.attrib.get('theoremLabel', 'Theorem') + ': ' + self.attrib.get('theoremTitle','') + '''}
''' + self.text + r'''
\end{''' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'theorem'
theorem = etree.Element('div')
theorem.attrib['class'] = environment
title = etree.Element('h1')
title.text = self.attrib.get('theoremLabel', 'Theorem') + ': ' + self.attrib.get('theoremTitle','')
title.tail=self.text
theorem.append(title)

return etree.tostring(theorem)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//theorem/label</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['theoremLabel'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//theorem/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['theoremTitle'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//theorem/statement</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner teacher">
environment = 'TheoremStatement'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'statement'
theoremstatement = etree.Element('div')
theoremstatement.attrib['class'] = environment
theoremstatement.text = self.text
return etree.tostring(theoremstatement)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//theorem/given</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner teacher">
environment = 'TheoremGiven'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'given'
theoremgiven = etree.Element('div')
theoremgiven.attrib['class'] = environment
theoremgiven.text = self.text
return etree.tostring(theoremgiven)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//theorem/required</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner teacher">
environment = 'TheoremRequired'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'required'
theoremrequired = etree.Element('div')
theoremrequired.attrib['class'] = environment
theoremrequired.text = self.text
return etree.tostring(theoremrequired)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//theorem/proof</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner teacher">
environment = 'TheoremProof'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'proof'
theoremproof = etree.Element('div')
theoremproof.attrib['class'] = environment
theoremproof.text = self.text
return etree.tostring(theoremproof)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//activity</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>type</name>
	<type>enum("activity","groupdiscussion","casestudy","investigation","f_experiment","i_experiment","g_experiment","project","questions","revision")</type>
      </entry>
    </attributes>
    <children>
      <optional>title</optional>
      <reference>block-element</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher"><!-- type already creates start of environment -->
activityType = self.attrib['type']
if activityType == 'f_experiment':
    environment = 'ActivityFormalexperiment'
elif activityType == 'g_experiment':
    environment = 'ActivityGeneralexperiment'
elif activityType == 'i_experiment':
    environment = 'ActivityInformalexperiment'
else:
    environment = 'Activity' + activityType.capitalize()
return '\n\\begin{' + environment + '}{' + self.attrib.get('title', '') + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher"><!-- type already creates start of environment -->
activityType = self.attrib['type']
if activityType == 'f_experiment':
    environment = 'formalexperiment'
elif activityType == 'g_experiment':
    environment = 'generalexperiment'
elif activityType == 'i_experiment':
    environment = 'informalexperiment'
else:
    environment = activityType.capitalize()

activity = etree.Element('div')
activity.attrib['class'] = 'activity'
activity.attrib['type'] = environment
activity.text = self.text
activity.tail = '\n'
return etree.tostring(activity)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//activity/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner teacher">
self.getparent().attrib['title'] = self.text.strip()
return ''
    </conversion-callback>
    <conversion-callback name="html learner teacher">
title = etree.Element('h1')
title.attrib['class']= 'title'
title.text = self.text
return etree.tostring(title)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//note</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>type</name>
	<type>enum("note","tip","aside","warning","important","keyquestions","newwords","didyouknow", "visit","keyconcepts","takenote")</type>
      </entry>
    </attributes>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher"><!-- type already creates start of environment -->
environment = 'Note' + self.attrib['type'].capitalize()
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher"><!-- type already creates start of environment -->
environment = 'note'
note = etree.Element('div')
note.attrib['class'] = environment
note.attrib['data-type'] = self.attrib['type']
note.text = self.text
return etree.tostring(note)
    </conversion-callback>
  </entry>

<entry>
    <xpath>/document/content//quote</xpath>
      <children>
          <reference>block-element-no-subsections</reference>
      </children>
    <attributes>
        <entry>
            <name>url</name>
            <type>string</type>
            <default/>
        </entry>
    </attributes>
    <conversion-callback name="latex learner teacher">
environment = 'Quote'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
</entry>


<entry>
    <xpath>/document/content//math_identity</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher"><!-- type already creates start of environment -->
environment = 'Mathidentity'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher"><!-- type already creates start of environment -->
environment = 'mathidentity'
mathidentity = etree.Element('div')
mathidentity.attrib['class'] = environment
mathidentity.text = self.text
return etree.tostring(mathidentity)
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//math_extension</xpath>
    <children>
      <element>title</element>
      <element>body</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher"><!-- type already creates start of environment -->
environment = 'Mathextension'
return '\n\\begin{' + environment + '}{' + self.attrib['title'] + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher"><!-- type already creates start of environment -->
environment = 'mathextension'
mathextension = etree.Element('div')
mathextension.attrib['class'] = environment
title = etree.Element('div')
title.text = self.attrib['title']
title.tail = self.text
mathextension.append(title)
return etree.tostring(mathextension)
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//math_extension/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//math_extension/body</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//linked-concepts</xpath>
    <children>
      <any-number from="1">
	<element>concept</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
return r'\paragraph{Key Mathematics Concepts} \begin{itemize}' + '\n' + self.text.strip() + '\n' + r'\end{itemize}' + '\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
linkedconcept = etree.Element('div')
linkedconcept.attrib['class'] = 'linkedconcept'
linkedconcept.text = "Key Mathematics Concepts"
mylist = etree.Element('ul')
mylist.text=self.text
linkedconcept.append(mylist)
return etree.tostring(mylist)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//linked-concepts/concept</xpath>
    <children>
      <element>text</element>
      <element>subject</element>
      <element>grade</element>
      <element>chapter</element>
      <optional>shortcode</optional>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
return r'\item ' + self.text + '\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
li = etree.Element('li')
li.text = self.text
return etree.tostring(li)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//linked-concepts/concept/text</xpath>
    <conversion-callback name="latex html learner teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//linked-concepts/concept/subject</xpath>
    <validation-callback>is_subject</validation-callback>
    <conversion-callback name="latex html learner teacher">
subject = self.text.strip().lower()
return u' â€” ' + {'maths': 'Mathematics', 'science': 'Physical Sciences'}[subject]
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//linked-concepts/concept/grade</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner teacher">
return ', Grade %i'%(int(self.text))
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//linked-concepts/concept/chapter</xpath>
    <conversion-callback name="latex html learner teacher">
return ', ' + self.text.capitalize()
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//linked-concepts/concept/shortcode</xpath>
    <validation-callback>is_section_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//key-concepts</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'Keyconcepts'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'keyconcepts'
kc = etree.Element('div')
kc.attrib['class'] = 'key-concepts'
kc.text = self.text

return etree.tostring(kc)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//new-words</xpath>
    <children>
      <any-number>
	<element>word</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'Newwords'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'Newwords'
nw = etree.Element('ul')
nw.attrib['data-class'] = environment
nw.text = self.text
return etree.tostring(nw)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//new-words/word</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner teacher">
environment = 'NewwordsWord'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'NewwordsWord'
word = etree.Element('li')
word.attrib['data-class'] = environment
word.text = self.text
return etree.tostring(word)
</conversion-callback>
  </entry>

<!-- Start of Monassis template spec -->

  <entry>
    <xpath>/document/content//monassis-template</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>rendered-as</name>
	<type>enum("example","exercise")</type>
	<default>exercise</default>
      </entry>
    </attributes>
    <children>
      <element>title</element>
      <element>content</element>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>repeat-problem</name>
	<type>number</type>
	<default>1</default>
      </entry>
    </attributes>
    <children>
      <optional>header</optional>
      <element>problem</element>
      <optional>response</optional>
      <element>solution</element>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/header</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/problem</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response</xpath>
    <children>
      <element>type</element>
      <element>marks</element>
      <element>correct</element>
      <element>query</element>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/type</xpath>
    <children>
      <any-number>
	<element>value</element>
      </any-number>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/type/value</xpath>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/marks</xpath>
    <children>
      <any-number>
	<element>value</element>
      </any-number>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/marks/value</xpath>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/correct</xpath>
    <children>
      <any-number>
	<element>value</element>
      </any-number>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/correct/value</xpath>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/query</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections-with-input</reference>
	<reference>inline-element-with-input</reference>
      </one-of>
    </children>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/response/query//input</xpath>
    <notext/>
  </entry>

  <entry id="block-element-no-subsections-with-input">
    <children>
      <any-number>
	<one-of>
	  <reference>block-element-no-subsections</reference>
	  <element>input</element>
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry id="inline-element-with-input">
    <children>
      <any-number>
	<one-of>
	  <reference>inline-element</reference>
	  <element>input</element>
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/solution</xpath>
    <children>
      <one-of>
	<any-number>
	  <element>step</element>
	</any-number>
	<reference>block-element-no-subsections</reference>
      </one-of>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/solution/step</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>marks</name>
	<type>number</type>
	<default>1</default>
      </entry>
    </attributes>
    <children>
      <optional>title</optional>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
  </entry>

  <entry>
    <xpath>/document/content//monassis-template/content/solution/step/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
  </entry>

<!-- End of Monassis template spec -->

  <entry>
    <xpath>/document/content//worked_example</xpath>
    <children>
      <element>title</element>
      <element>question</element>
      <element>answer</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'Workedexample'
return '\n\\begin{' + environment + '}{' + self.attrib['title'] + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
environment = 'worked_example'
workedexample = etree.Element('div')
workedexample.attrib['class'] = environment
title = etree.Element('h1')
title.attrib['class'] = 'title'
title.tail = self.text
title.text = self.attrib['title']
workedexample.append(title)

return etree.tostring(workedexample)
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//worked_example/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text.strip()
return ''
    </conversion-callback>
    <conversion-callback name="html latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//worked_example/question</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner teacher">
if self.text is None:
    raise ValueError, "Worked example question should not be empty."
environment = 'WorkedexampleQuestion'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
if self.text is None:
    raise ValueError, "Worked example question should not be empty."
workedexampleq = etree.Element('div')
workedexampleq.attrib['class'] = 'question'
workedexampleq.text = self.text

return etree.tostring(workedexampleq)
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//worked_example/answer</xpath>
    <children>
      <one-of>
	<any-number from="1">
	  <element>workstep</element>
	</any-number>
	<reference>block-element-no-subsections</reference>
      </one-of>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
if self.text is None:
    raise ValueError, "Worked example answer should not be empty."
environment = 'WorkedexampleAnswer'
return '\n\\begin{' + environment + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
return self.text
    </conversion-callback>
    <conversion-callback name="latex html correct"/>
  </entry>

  <entry>
    <xpath>/document/content//worked_example/answer/workstep</xpath>
    <children>
      <element>title</element>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
environment = 'WorkedexampleAnswerWorkstep'
return '\n\\begin{' + environment + '}{' + self.attrib['title'] + '}\n' + self.text + r'\end{' + environment + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
workstep = etree.Element('div')
workstep.attrib['class'] = 'workstep'
title = etree.Element('h2')
title.attrib['class'] = 'title'
title.text = self.attrib['title']
title.tail = '\n'+self.text
workstep.append(title)
return etree.tostring(workstep)
    </conversion-callback>
    <conversion-callback name="latex html correct"/>
  </entry>

  <entry>
    <xpath>/document/content//worked_example/answer/workstep/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text.strip()
return ''
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//presentation</xpath>
    <children>
      <unordered>
	<element>title</element>
	<optional>shortcode</optional>
	<element>url</element>
      </unordered>
    </children>
    <conversion-callback name="latex learner teacher">
return r'\presentation{' + self.attrib.get('shortcode', 'SHORTCODE') + '}{' + self.attrib.get('title', 'TITLE') + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
presentation = etree.Element('p')
presentation.attrib['data-class'] = 'presentation'
presentation.attrib['id'] = 'sc' + self.attrib.get('shortcode', 'SHORTCODE')
url = etree.Element('a')
url.attrib['href'] = self.attrib.get('url')
url.text = 'Presentation: %s'%self.attrib.get('shortcode')
presentation.text = '%s'% etree.tostring(url)


return etree.tostring(presentation)
</conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//presentation/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//presentation/shortcode</xpath>
    <validation-callback>is_rich_media_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['shortcode'] = self.text
return ''
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//presentation/url</xpath>
    <conversion-callback name="latex learner teacher"/>
    <conversion-callback name="html learner teacher">
self.getparent().attrib['url'] = self.text
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//simulation</xpath>
    <children>
      <unordered>
	<element>title</element>
	<optional>shortcode</optional>
	<element>url</element>
	<element>embed</element>
	<optional>width</optional>
	<optional>height</optional>
      </unordered>
    </children>
    <validation-callback>simulation_has_url_or_embed</validation-callback>
    <conversion-callback name="latex learner teacher">
return r'\simulation{' + self.attrib.get('shortcode', 'SHORTCODE') + '}{' + self.attrib.get('title', 'TITLE') + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
simulation = etree.Element('p')
simulation.attrib['data-class'] = 'simulation'
simulation.attrib['id'] = 'sc' + self.attrib.get('shortcode', 'SHORTCODE')
url = etree.Element('a')
url.attrib['href'] = self.attrib.get('url')
url.text = 'Simulation: %s'%self.attrib.get('shortcode')
simulation.text = '%s'% etree.tostring(url)

return etree.tostring(simulation)
</conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//simulation/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//simulation/shortcode</xpath>
    <validation-callback>is_rich_media_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['shortcode'] = self.text
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//simulation/width</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//simulation/height</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//simulation/url</xpath>
    <conversion-callback name="latex learner teacher"/>
    <conversion-callback name="html learner teacher">
    self.getparent().attrib['url'] = self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//simulation/embed</xpath>
    <validation-callback>is_valid_html</validation-callback>
    <conversion-callback name="latex html learner teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//video</xpath>
    <children>
      <unordered>
	<element>title</element>
	<any-number from="1"><!-- with multiple urls, the first one will be linked to and the rest are for reference only -->
	  <element>url</element>
	</any-number>
	<optional>shortcode</optional>
	<optional>width</optional>
	<optional>height</optional>
      </unordered>
    </children>
    <conversion-callback name="latex learner teacher">
return r'\video{' + self.attrib.get('shortcode', 'SHORTCODE') + '}{' + self.attrib.get('title', 'TITLE') + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner teacher">
video = etree.Element('p')
video.attrib['data-class'] = 'video'
video.attrib['id'] = 'sc' + self.attrib.get('shortcode', 'SHORTCODE')
url = etree.Element('a')
url.attrib['href'] = self.attrib.get('url')
url.text = 'Video: %s'%self.attrib.get('shortcode')
video.text = '%s'% etree.tostring(url)

return etree.tostring(video)
</conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//video/title</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['title'] = self.text
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//video/shortcode</xpath>
    <validation-callback>is_rich_media_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
self.getparent().attrib['shortcode'] = self.text
return ''
    </conversion-callback>
    <conversion-callback name="latex correct"/>
  </entry>

  <entry>
    <xpath>/document/content//video/url</xpath>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['url'] = self.text
</conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//video/width</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//video/height</xpath>
    <validation-callback>is_integer</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//figure</xpath>
    <children>
      <element>type</element>
      <any-number from="1">
	<one-of>
	  <element>table</element>
	  <element>pspicture</element>
	  <element>tikzpicture</element>
	  <element>image</element>
	  <element>para</element>
	  <element>equation</element>
	  <element>latex</element>
	</one-of>
      </any-number>
      <optional>caption</optional>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher"><!-- type already creates start of environment -->
environment = 'Figure' + self.attrib['type'].capitalize()
result = '\n\\begin{' + environment + '}\n' + self.text
id = self.attrib.get('id')
if id is not None:
    result += r'\label{' + id + '}\n'
result += r'\end{' + environment + '}\n'
return result
    </conversion-callback>
    <conversion-callback name="html learner correct teacher"><!-- type already creates start of environment -->
# if the figure contains an image
if self.attrib['type'] == 'figure':
    figure = etree.Element('figure')
    figure.text = self.text
else:
    environment = 'Figure' + self.attrib['type'].capitalize()
    id = self.attrib.get('id')
    figure = etree.Element('div')
    figure.attrib['data-class'] = environment
    if id is not None:
        figure.attrib['id'] = id
    figure.text = self.text

return etree.tostring(figure)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//pspicture</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>style:width</name>
	<type>number</type>
	<default/>
      </entry>
      <entry>
	<name>crop</name>
	<type>enum("true","false")</type>
	<default>false</default>
      </entry>
    </attributes>
    <children>
      <any-number>
	<element>usepackage</element>
      </any-number>
      <element>code</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
redBoundingBox = True # Put red frame at bounding box of every pspicture?

if self.attrib['crop'] == 'true':
    pspictureEnvironment = 'pspicture*'
else:
    pspictureEnvironment = 'pspicture'

tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
if self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width') is not None:
    relativeWidth = float(self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width'))
    # Get width of pspicture
    start = self.text.find('(')+1
    stop = self.text.find(',', start)
    xmin = float(self.text[start:stop])
    start = self.text.find('(', stop)+1
    stop = self.text.find(',', start)
    xmax = float(self.text[start:stop])
    pspictureWidthInCm = xmax-xmin
    pspictureWidthInPt = pspictureWidthInCm * 28.3464567
    head += r'\FPdiv\scaleparam{\getlengthinpt{\textwidth}}{' + str(pspictureWidthInPt/relativeWidth) + r'}\par\par\scalebox{\scaleparam}{\begin{' + pspictureEnvironment + '}'
    tail = r'\end{' + pspictureEnvironment + '}}\n' + tail
else:
    head += r'\par\begin{' + pspictureEnvironment + '}'
    tail = r'\end{' + pspictureEnvironment + '}\n' + tail

if redBoundingBox:
    start = self.text.find('(')
    stop = self.text.find(')', start)
    stop = self.text.find(')', stop+1)+1
    nextLine = self.text.find('\n', stop)+1
    text = self.text[:nextLine] + r'\psframe[linecolor=red]' + self.text[start:stop] + '\n' + self.text[nextLine:]
else:
    text = self.text

return head + text + tail
    </conversion-callback>
    <conversion-callback name="latex correct">
if self.attrib['crop'] == 'true':
    pspictureEnvironment = 'pspicture*'
else:
    pspictureEnvironment = 'pspicture'

tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'

relativeWidth = 1
# Get width of pspicture
start = self.text.find('(')+1
stop = self.text.find(',', start)
xmin = float(self.text[start:stop])
start = self.text.find('(', stop)+1
stop = self.text.find(',', start)
xmax = float(self.text[start:stop])
pspictureWidthInCm = xmax-xmin
pspictureWidthInPt = pspictureWidthInCm * 28.3464567
head += r'\FPdiv\scaleparam{\getlengthinpt{\linewidth}}{' + str(pspictureWidthInPt/relativeWidth) + r'}\par\par\scalebox{\scaleparam}{\begin{' + pspictureEnvironment + '}'
tail = r'\end{' + pspictureEnvironment + '}}\n' + tail

return head + self.text + tail
    </conversion-callback>
    <conversion-callback name="html learner teacher">
code = self.find('.//code').text
#TODO fix this, image names don't match the actual names.
# bad hack, strip out all non-ascii characters from code element to calculate hash
codetext = ''.join([c  for c in code if ord(c) &lt; 128])
codeHash = hashlib.md5(''.join(codetext.encode('utf-8').split())).hexdigest()

pre = etree.Element('pre')
pre.attrib['class'] = 'pspicture'
code_element = self.find('.//code')
pre.append(copy.deepcopy(code_element))

pspicture = etree.Element('div')
pspicture.attrib['class'] = 'alternates'

img = etree.Element('img')
img_path = '_plone_ignore_/cache/pspictures/%s.png'%codeHash
# check if the file has been created already
try:
    with open(img_path): pass
# if not, create the file
except IOError:
    try:
        png = pspicture2png(self)
        os.system('cp %s %s' % (png, img_path))
    except Exception as E:
        warning_message("Problem compiling pstricks\n\nException:\n%s\n\n" % E + etree.tostring(self))
        png = ''

img.attrib['src'] = img_path
#if width is not None:
#    img.attrib['width'] = str(int(float(width)*780))
#else:
#    img.attrib['width'] = '780'
#
#img.attrib['alt'] = self.attrib.get('attribution')

# add usepackages to pre element


for up in self.findall('.//usepackage'):
    pre.append(up)

pspicture.append(img)
pspicture.append(pre)
return etree.tostring(pspicture)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//pspicture/usepackage</xpath>
    <conversion-callback name="latex learner correct teacher">
if self.text.strip() not in ['pst-solides3d', 'pst-3dplot', 'pst-node']:
    warning_message('REQUIRED PSTRICKS PACKAGE: ' + self.text)
return ''
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return 
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//pspicture/code</xpath>
    <children>
      <any-number>
	<one-of>
	  <element>unit_number</element>
	  <element>number</element>
	  <element>unit</element>
	  <element>percentage</element>
	  <element>currency</element>
	  <element>chem_compound</element>
	  <element>spec_note</element>
	  <element>nuclear_notation</element>
	  <element>nth</element>
	</one-of>
      </any-number>
    </children>
    <conversion-callback name="latex learner correct teacher">
return self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return 
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//tikzpicture</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>style:width</name>
	<type>number</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <any-number>
	<element>usepackage</element>
      </any-number>
      <element>code</element>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
if self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width') is not None:
    warning_message('UNHANDLED style:width in tikzpicture')
return head + r'\par\begin{tikzpicture}' + self.text + r'\end{tikzpicture}' + '\n' + tail
    </conversion-callback>
    <conversion-callback name="latex correct">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
return head + r'\par\scalebox{0.5}{\begin{tikzpicture}' + self.text + r'\end{tikzpicture}}' + '\n' + tail
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//tikzpicture/usepackage</xpath>
    <conversion-callback name="latex learner correct teacher">
warning_message('REQUIRED TIKZ PACKAGE: ' + self.text)
return ''
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
usepackage = etree.Element('usepackage')
usepackage.text = self.text
return etree.tostring(usepackage)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//tikzpicture/code</xpath>
    <children>
      <any-number>
	<one-of>
	  <element>unit_number</element>
	  <element>number</element>
	  <element>unit</element>
	  <element>percentage</element>
	  <element>currency</element>
	  <element>chem_compound</element>
	  <element>spec_note</element>
	  <element>nuclear_notation</element>
	  <element>nth</element>
	</one-of>
      </any-number>
    </children>
    <conversion-callback name="latex learner correct teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//image</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>style:width</name>
	<type>number</type>
	<default/>
      </entry>
      <entry>
        <name>src</name>
        <type>string</type>
        <default/>
      </entry>
      <entry>
        <name>width</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>height</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>mime-type</name>
        <type>string</type>
        <default/>
      </entry>
      <entry>
        <name>src</name>
        <type>string</type>
        <default/>
      </entry>
      <entry>
        <name>width</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>height</name>
        <type>number</type>
        <default/>
      </entry>
      <entry>
        <name>mime-type</name>
        <type>string</type>
        <default/>
      </entry>
      <!--<entry>
	<name>style:format</name>
	<type>string</type>
	<default/>
      </entry>-->
    </attributes>
    <children>
      <subset-of>
        <element>src</element>
        <element>attribution</element>
      </subset-of>
    </children>
    <notext/>
    <conversion-callback name="latex learner teacher">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
result = r'\includegraphics'
width = self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width')
if width is not None:
    result += r'[width=%s\textwidth]'%width
else:
    width = self.attrib.get('width')
    if width is not None:
        result += r'[width=%s\textwidth]'%(float(width)/800.0)
result += '{' + self.attrib['src'] + '}\n'
if self.attrib.has_key('attribution'):
    result += r'\ImageAttribution{' + self.attrib['attribution'] + '}\n'
return head + result + tail
    </conversion-callback>
    <conversion-callback name="html learner teacher">
width = self.attrib.get('{http://siyavula.com/cnxml/style/0.1}width')
img = etree.Element('img')
img.attrib['src'] = self.attrib['src']
if width is not None:
    img.attrib['width'] = str(int(float(width)*780))
else:
    img.attrib['width'] = '300'

if self.attrib.get('attribution') is not None:
    img.attrib['alt'] = self.attrib.get('attribution')

return etree.tostring(img)
</conversion-callback>
    <conversion-callback name="latex correct">
tableMode = ('table' in utils.get_full_dom_path(self))
if tableMode:
    head = ''
    tail = ''
else:
    head = '\\begin{Image}\n'
    tail = '\\end{Image}\n'
result = r'\includegraphics'
result += r'[width=\linewidth]'
result += '{' + self.attrib['src'] + '}\n'
return head + result + tail
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//image/src</xpath>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['src'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//image/attribution</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['attribution'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//figure/type</xpath>
    <validation-callback>is_figure_type</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
self.getparent().attrib['type'] = self.text.strip()
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//figure/caption</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex learner correct teacher">
if self.text.strip().startswith(r'\par'):
    self.text = self.text.strip()[4:]
return r'  \Caption{' + self.text.strip() + '}\n'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
if self.getparent().attrib['type'] == 'figure':
    caption = etree.Element('figcaption')
else:
    caption = etree.Element('div')

caption.attrib['class'] = 'caption'
caption.text = self.text

return '\n'+etree.tostring(caption)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//equation</xpath>
    <children>
      <element>m:math</element>
    </children>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//latex</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>display</name>
	<type>enum("inline","block")</type>
	<default>inline</default>
      </entry>
    </attributes>
    <children>
      <any-number>
	<one-of>
	  <element>number</element>
	  <element>unit</element>
	  <element>unit_number</element>
	  <element>percentage</element>
	  <element>currency</element>
	  <element>correct</element>
	</one-of>
      </any-number>
    </children>
    <conversion-callback name="latex learner correct teacher">
# First check that there aren't any funny functions
unslashedFunctions = latex_math_function_check(self.text)
if len(unslashedFunctions) > 0:
    warning_message('Found the following functions: (%s) without a backslash in a latex element:\n%s'%(', '.join(unslashedFunctions), self.text))

insideTable = ('table' in utils.get_full_dom_path(self))

numberEquations = False
if self.attrib['display'] == 'inline':
    return r'\(' + self.text.strip() + r'\)'
else:
    foundMathEnvironment = False
    text = self.text.strip()
    beginPattern = r'\begin{%s}'
    endPattern = r'\end{%s}'
    for environmentName in ['align', 'align*', 'aligned', 'aligned*', 'equation', 'equation*', 'eqnarray', 'eqnarray*']:
        beginSubstr = beginPattern%environmentName
        if text[:len(beginSubstr)] == beginSubstr:
            endSubstr = endPattern%environmentName
            if text[-len(endSubstr):] != endSubstr:
                error_message('You are either missing a \\end{%s} in a LaTeX environment or there is a mismatch between the \\begin and \\end.'%environmentName)
            if environmentName in ['eqnarray', 'eqnarray*']:
                warning_message('You should really be using align rather eqnarray in your &lt;latex&gt; elements')

            # Normalise align
            if environmentName in ['align', 'align*', 'aligned', 'aligned*']:
                if insideTable:
                    replacement = 'aligned'
                else:
                    replacement = 'align'
                newBeginSubstr = beginPattern%replacement
                newEndSubstr = endPattern%replacement
                text = newBeginSubstr + text[len(beginSubstr):-len(endSubstr)] + newEndSubstr
                environmentName = replacement
                beginSubstr = newBeginSubstr
                endSubstr = newEndSubstr

            foundMathEnvironment = True
            if not numberEquations:
                if environmentName[-1] != '*':
                    text = beginSubstr[:-1] + '*}' + text[len(beginSubstr):-len(endSubstr)] + endSubstr[:-1] + '*}'
                    beginSubstr = beginSubstr[:-1] + '*}'
                    endSubstr = endSubstr[:-1] + '*}'
            break
    if not foundMathEnvironment:
        return '\\[' + text + '\\]\n'
    else:
        environmentsWithAmpersands = {'align': 1, 'align*': 1, 'eqnarray': 2, 'eqnarray*': 2}
        if environmentName in environmentsWithAmpersands:
            # Check number of ampersands per line
            ampersands = environmentsWithAmpersands[environmentName]
            lines = text.split('\\\\')
            for lineIndex in range(len(lines)):
                line = lines[lineIndex].strip()
                if line.count('&amp;') &gt; ampersands:
                    error_message('Extra ampersands (expected %i) in aligned equation: %s'%(ampersands, line))
                if (lineIndex == len(lines)-1) and (line == endSubstr):
                    error_message('Extra \\\\ at end of aligned equation: %s'%(text.strip()))
        return text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
def make_new_mathelement(TeX):
    mathmlelement = etree.Element('math')
    semantics = etree.Element('semantics')
    junk = etree.Element('mtext')
    junk.text = 'CLICKME'
    semantics.append(junk)
    annotation = etree.Element('annotation')
    annotation.attrib['encoding'] = 'TeX'
    annotation.text = TeX

    semantics.append(annotation)
    mathmlelement.append(semantics)
    return etree.tostring(mathmlelement)

# First check that there aren't any funny functions
unslashedFunctions = latex_math_function_check(self.text)
if len(unslashedFunctions) > 0:
    warning_message('Found the following functions: (%s) without a backslash in a latex element:\n%s'%(', '.join(unslashedFunctions), self.text))

insideTable = ('table' in utils.get_full_dom_path(self))

numberEquations = False
if self.attrib['display'] == 'inline':
    return make_new_mathelement(self.text.strip()) #r'\(' + self.text.strip() + r'\)'
else:
    foundMathEnvironment = False
    text = self.text.strip()
    beginPattern = r'\begin{%s}'
    endPattern = r'\end{%s}'
    for environmentName in ['align', 'align*', 'aligned', 'aligned*', 'equation', 'equation*', 'eqnarray', 'eqnarray*']:
        beginSubstr = beginPattern%environmentName
        if text[:len(beginSubstr)] == beginSubstr:
            endSubstr = endPattern%environmentName
            if text[-len(endSubstr):] != endSubstr:
                error_message('You are either missing a \\end{%s} in a LaTeX environment or there is a mismatch between the \\begin and \\end.'%environmentName)
            if environmentName in ['eqnarray', 'eqnarray*']:
                warning_message('You should really be using align rather eqnarray in your &lt;latex&gt; elements')

            # Normalise align
            if environmentName in ['align', 'align*', 'aligned', 'aligned*']:
                if insideTable:
                    replacement = 'aligned'
                else:
                    replacement = 'align'
                newBeginSubstr = beginPattern%replacement
                newEndSubstr = endPattern%replacement
                text = newBeginSubstr + text[len(beginSubstr):-len(endSubstr)] + newEndSubstr
                environmentName = replacement
                beginSubstr = newBeginSubstr
                endSubstr = newEndSubstr

            foundMathEnvironment = True
            if not numberEquations:
                if environmentName[-1] != '*':
                    text = beginSubstr[:-1] + '*}' + text[len(beginSubstr):-len(endSubstr)] + endSubstr[:-1] + '*}'
                    beginSubstr = beginSubstr[:-1] + '*}'
                    endSubstr = endSubstr[:-1] + '*}'
            break
    if not foundMathEnvironment:
        return make_new_mathelement(text) #r'\[' + text + r'\]'
    else:
        environmentsWithAmpersands = {'align': 1, 'align*': 1, 'eqnarray': 2, 'eqnarray*': 2}
        if environmentName in environmentsWithAmpersands:
            # Check number of ampersands per line
            ampersands = environmentsWithAmpersands[environmentName]
            lines = text.split('\\\\')
            for lineIndex in range(len(lines)):
                line = lines[lineIndex].strip()
                if line.count('&amp;') &gt; ampersands:
                    error_message('Extra ampersands (expected %i) in aligned equation: %s'%(ampersands, line))
                if (lineIndex == len(lines)-1) and (line == endSubstr):
                    error_message('Extra \\\\ at end of aligned equation: %s'%(text.strip()))
        return make_new_mathelement(text) #text

    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//m:math</xpath>
    <children>
      <reference>math-stuff</reference>
    </children>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
tex = mathml_transform(self)
tex = unicode(tex).replace('$', '')
if tex.count(r'\left') != tex.count(r'\right'):
    tex = tex.replace(r'\left', '').replace(r'\right', '')

# replace the stackrel{^} with hat
tex = tex.replace(r'\stackrel{^}', r'\hat')

# fix the \times symbol
tex = tex.replace(u'Ã—', r'\times ')

# fix the trig functions too
for func in ['sin', 'cos', 'tan', 'cot']:
    tex = tex.replace(' ' + func, '\\' + func + ' ')

# Check that there aren't any funny functions
unslashedFunctions = latex_math_function_check(tex)
if len(unslashedFunctions) > 0:
    warning_message('Found the following functions: (%s) without a backslash in a m:math element (converted to LaTeX):\n%s'%(', '.join(unslashedFunctions), tex))

return r'\(' + tex + r'\)'
    </conversion-callback>
  </entry>

  <entry><xpath>/document/content//m:mrow</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mfrac</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mfenced</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mi</xpath><children><reference>math-stuff</reference></children><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mo</xpath><children><reference>math-stuff</reference></children><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mn</xpath><children><reference>math-stuff</reference></children><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mtable</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mtr</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mtd</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mtext</xpath><children><reference>math-stuff</reference></children><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:msub</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:msup</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:msubsup</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mspace</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mphantom</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mstyle</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mover</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:msqrt</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:munder</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:munderover</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mroot</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>
  <entry><xpath>/document/content//m:mref</xpath><children><reference>math-stuff</reference></children><notext/><conversion-callback name="latex html learner correct teacher"/></entry>

  <entry id="math-stuff">
    <children>
      <any-number>
	<one-of>
	  <element>m:mrow</element>
	  <element>m:mfrac</element>
	  <element>m:mfenced</element>
	  <element>m:mi</element>
	  <element>m:mo</element>
	  <element>m:mn</element>
	  <element>m:mtable</element>
	  <element>m:mtr</element>
	  <element>m:mtd</element>
	  <element>m:mtext</element>
	  <element>m:msub</element>
	  <element>m:msup</element>
	  <element>m:msubsup</element>
	  <element>m:mspace</element>
	  <element>m:mphantom</element>
	  <element>m:mstyle</element>
	  <element>m:mover</element>
	  <element>m:msqrt</element>
	  <element>m:munder</element>
	  <element>m:munderover</element>
	  <element>m:mroot</element>
	  <element>m:mref</element>
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry id="block-element">
    <children>
      <any-number>
	<one-of>
	  <element>section</element>
	  <reference>block-element-no-subsections-entry</reference>
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry id="block-element-no-subsections">
    <children>
      <any-number>
	<reference>block-element-no-subsections-entry</reference>
      </any-number>
    </children>
  </entry>

  <entry id="block-element-no-subsections-entry">
    <children>
      <one-of>
    <element>media</element>
	<element>para</element>
	<element>video</element>
	<element>presentation</element>
	<element>simulation</element>
	<element>list</element>
	<element>equation</element>
	<element>latex</element>
	<element>worked_example</element>
	<element>monassis-template</element>
	<element>figure</element>
	<element>image</element>
	<element>pspicture</element>
	<element>tikzpicture</element>
	<element>table</element>
	<element>definition</element>
	<element>theorem</element>
	<element>activity</element>
	<element>exercises</element>
	<element>note</element>
	<element>math_extension</element>
	<element>math_identity</element>
	<element>key-concepts</element>
	<element>new-words</element>
	<element>linked-concepts</element>
	<element>teachers-guide</element>
	<element>correct</element>
    <element>link</element>
    <element>quote</element>

	<element>todo</element><!-- This needs to go away before publising the print textbooks -->
      </one-of>
    </children>
  </entry>

  <entry id="inline-container-element">
    <children>
      <any-number>
	<one-of>
	  <element>br</element>
      <element>space</element>
      <element>newline</element>
	  <element>chem_compound</element>
	  <element>correct</element>
	  <element>currency</element>
	  <element>emphasis</element>
	  <element>image</element>
	  <element>latex</element>
	  <element>link</element>
	  <element>list</element>
	  <element>m:math</element>
	  <element>nth</element>
	  <element>nuclear_notation</element>
	  <element>number</element>
	  <element>percentage</element>
	  <element>spec_note</element>
	  <element>sub</element>
	  <element>sup</element>
	  <element>unit_number</element>
	  <element>unit</element>

	  <element>todo</element><!-- This needs to go away before publising the print textbooks -->
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry id="inline-element">
    <children>
      <any-number>
	<one-of>
	  <element>br</element>
      <element>newline</element>
      <element>space</element>
	  <element>chem_compound</element>
	  <element>correct</element>
	  <element>currency</element>
	  <element>emphasis</element>
	  <element>image</element>
	  <element>latex</element>
	  <element>link</element>
	  <element>m:math</element>
	  <element>nth</element>
	  <element>nuclear_notation</element>
	  <element>number</element>
	  <element>percentage</element>
	  <element>spec_note</element>
	  <element>sub</element>
	  <element>sup</element>
	  <element>unit_number</element>
	  <element>unit</element>
	</one-of>
      </any-number>
    </children>
  </entry>

  <entry>
    <xpath>/document/content//unit_number</xpath>
    <children>
      <element>number</element>
      <element>unit</element>
    </children>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
return self.text
    </conversion-callback>
  </entry>

  <!-- //currency/number shadows //number -->
  <entry>
    <xpath>/document/content//currency/number</xpath>
    <validation-callback>is_float</validation-callback>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//number</xpath>
    <children>
      <subset-of>
	<element>coeff</element>
	<element>base</element>
	<element>exp</element>
      </subset-of>
    </children>
    <validation-callback>is_number</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
if len(self) == 0:
    if 'e' in self.text:
        # Number in exponential notation: convert to coeff and exp
        numberText = self.text.strip()
        self.text = None
        self.append(etree.Element('coeff'))
        pos = numberText.find('e')
        self[-1].text = numberText[:pos]
        self.append(etree.Element('exp'))
        self[-1].text = str(int(numberText[pos+1:]))
    else:
        # No children, means it's just a plain number
        numberText = self.text.strip()
        self.text = None
        self.append(etree.Element('coeff'))
        self[-1].text = numberText

# Parse out coefficient, base and exponent
nodes = {}
text = {}
for key in ['coeff', 'exp', 'base']:
    nodes[key] = self.find(key)
    text[key] = nodes[key].text.strip() if nodes[key] is not None else None
if text['base'] is None:
    text['base'] = '10'
for key in text:
    if text[key] is None: continue
    if text[key][0] == '-':
        minus = '-'
        text[key] = text[key][1:]
    else:
        minus = ''
    text[key] = minus + r'\text{' + utils.format_number(text[key], thousandsSeparator=r'\ ') + '}'

# Build LaTeX representation
result = text['coeff'] if nodes['coeff'] is not None else ''
if nodes['exp'] is not None:
    if nodes['coeff'] is not None:
        result += r' \times '
    result += text['base'] + '^{' + text['exp'] + '}'

# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'

return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//number/coeff</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//number/base</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//number/exp</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//unit</xpath>
    <children>
      <any-number>
	<element>sup</element>
      </any-number>
    </children>
    <validation-callback>is_unit</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
unitsWithoutSpace = [u'Â°']
inUnitNumber = (self.getparent().tag == 'unit_number')
result = r'\text{' + self.text + '}'
# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'
    if inUnitNumber and (self.text[0] not in unitsWithoutSpace):
        result = '~' + result
else:
    if inUnitNumber and (self.text[0] not in unitsWithoutSpace):
        assert result[:6] == r'\text{', "Weird error in /document/content//unit conversion."
        result = result[:6] + ' ' + result[6:]
return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//unit/sup</xpath>
    <validation-callback>is_number</validation-callback>
    <conversion-callback name="latex learner correct teacher">
return '$^{' + self.text + '}$'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
parents = [a.tag for a in self.iterancestors()]
if 'latex' in parents:
    return '^{%s}'%self.text
else:
    sup = etree.Element('sup')
    sup.text = self.text
    return etree.tostring(sup)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//percentage</xpath>
    <validation-callback>is_float</validation-callback>
    <conversion-callback name="latex learner correct teacher">
return convert_using(self, '/document/content//number') + r'\%'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return convert_using(self, '/document/content//number') + r'%'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//currency</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>precision</name>
	<type>integer</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <unordered>
	<optional>symbol</optional>
	<element>number</element>
      </unordered>
    </children>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
numberText = self.find('number').text.strip()
try:
    int(numberText.strip())
    defaultPrecision = 0
except ValueError:
    defaultPrecision = 2
currencyPrecision = int(self.attrib.get('precision', defaultPrecision))
numberText = ("%%.%if"%currencyPrecision)%float(numberText)
numberText = utils.format_number(numberText, thousandsSeparator=r'\ ')

symbolNode = self.find('symbol')
if symbolNode is None:
    symbol = 'R'
    symbolLocation = 'front'
else:
    symbol = symbolNode.text.strip()
    symbolLocation = symbolNode.attrib.get('location', 'front')



if symbolLocation == 'front':
    result = symbol + r'\ ' + numberText
else:
    result = numberText + r'\ ' + symbol
result = r'\text{' + result + '}'

# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'

return result
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
numberText = self.find('number').text.strip()
try:
    int(numberText.strip())
    defaultPrecision = 0
except ValueError:
    defaultPrecision = 2
currencyPrecision = int(self.attrib.get('precision', defaultPrecision))
numberText = ("%%.%if"%currencyPrecision)%float(numberText)
numberText = utils.format_number(numberText, thousandsSeparator=r' ')

symbolNode = self.find('symbol')
if symbolNode is None:
    symbol = 'R'
    symbolLocation = 'front'
else:
    symbol = symbolNode.text.strip()
    symbolLocation = symbolNode.attrib.get('location', 'front')



if symbolLocation == 'front':
    result = symbol + r' ' + numberText
else:
    result = numberText + r' ' + symbol
result = r'\text{' + result + '}'

# Check whether already in math mode
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    result = r'\(' + result + r'\)'

return result
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//currency/symbol</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>location</name>
	<type>enum("front","back")</type>
	<default>front</default>
      </entry>
    </attributes>
  </entry>

  <entry>
    <xpath>/document/content//chem_compound</xpath>
    <conversion-callback name="latex html learner correct teacher">
text = self.text.strip()
pos = 0
while pos &lt; len(text):
    if text[pos].isalpha():
        start = pos
        pos += 1
        while (pos &lt; len(text)) and text[pos].isalpha():
            pos += 1
        text = text[:start] + r'\text{' + text[start:pos] + '}' + text[pos:]
        pos += 7
    else:
        pos += 1
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    text = r'\(' + text + r'\)'
return text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//spec_note</xpath>
    <conversion-callback name="latex html learner correct teacher">
return convert_using(self, '/document/content//chem_compound')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//nuclear_notation</xpath>
    <children>
      <unordered>
	<element>symbol</element>
	<element>mass_number</element>
	<element>atomic_number</element>
      </unordered>
    </children>
    <notext/>
    <validation-callback>is_nuclear_notation</validation-callback>
    <conversion-callback name="latex html learner correct teacher">
latex = r'_{%s}^{%s}\text{%s}'%(self.find('atomic_number').text, self.find('mass_number').text, self.find('symbol').text)
latexMode = ('latex' in utils.get_full_dom_path(self))
if not latexMode:
    latex = r'\(' + latex + r'\)'
return latex
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//nuclear_notation/symbol</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//nuclear_notation/mass_number</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//nuclear_notation/atomic_number</xpath>
    <conversion-callback name="latex html learner correct teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//br</xpath>
    <notext/>
    <conversion-callback name="latex learner correct teacher">
return r'\\'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return '\n'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//space</xpath>
    <notext/>
    <attributes>
        <entry>
            <name>count</name>
            <type>string</type>
        </entry>
        <entry>
            <name>effect</name>
            <type>string</type>
        </entry>
    </attributes>
    <conversion-callback name="latex learner correct teacher">
if self.attrib['effect'] == 'underline':
    return r'\underline{\hspace{%sem}}' % self.attrib['count']
else:
    return r'\hspace{%sem}' % self.attrib['count']
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
    return r'_'*int(self.attrib['count'])
    </conversion-callback>
  </entry>
<entry>
    <xpath>/document/content//space</xpath>
    <notext/>
    <attributes>
        <entry>
            <name>count</name>
            <type>string</type>
        </entry>
        <entry>
            <name>effect</name>
            <type>string</type>
        </entry>
    </attributes>
    <conversion-callback name="latex learner correct teacher">
if self.attrib['effect'] == 'underline':
    return r'\underline{\hspace{%sem}}' % self.attrib['count']
else:
    return r'\hspace{%sem}' % self.attrib['count']
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
    return r'_'*int(self.attrib['count'])
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//newline</xpath>
    <notext/>
    <attributes>
        <entry>
            <name>count</name>
            <type>string</type>
            <default/>
        </entry>
        <entry>
            <name>effect</name>
            <type>string</type>
            <default/>
        </entry>
    </attributes>
    <conversion-callback name="latex learner correct teacher">
if 'effect' in self.attrib.keys():
    if self.attrib['effect'] == 'underline':
        return r'\answerline{%s}' % self.attrib['count']
    elif self.attrib['effect'] == 'normal':
        return r'\answerspace{%s}' % self.attrib['count']
else:
    return r''
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
if 'effect' in self.attrib.keys():
    if self.attrib['effect'] == 'underline':
        return r'&lt;hr/&gt;'*int(self.attrib['count'])
    elif self.attrib['effect'] == 'normal':
        return r'&lt;br/&gt;'*int(self.attrib['count'])
else:
    return r''
    </conversion-callback>
  </entry>


  <entry>
    <xpath>/document/content//emphasis</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>effect</name>
	<type>enum("bold","italics","underline","smallcaps","normal")</type>
	<default>bold</default>
      </entry>
    </attributes>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
pattern = {
    'bold': r'\textbf{%s}',
    'italics': r'\textit{%s}',
    'underline': r'\underline{%s}',
    'smallcaps': r'\textsc{%s}',
    'normal': '%s',
}[self.attrib['effect']]
return pattern%self.text 
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
#pattern = {
#    'bold': r'\(\textbf{%s}\)',
#    'italics': r'\(\textit{%s}\)',
#    'underline': r'\(\underline{%s}\)',
#    'smallcaps': r'\(\textsc{%s}\)',
#    'normal': '%s',
#}[self.attrib['effect']]

if self.attrib['effect'] == 'bold':
    emph = etree.Element('strong')

elif self.attrib['effect'] == 'italics':
    emph = etree.Element('em')

elif self.attrib['effect'] == 'underline':
    emph = etree.Element('u')

elif self.attrib['effect'] == 'smallcaps':
    emph = etree.Element('span')
    emph.attrib['data-class'] = 'smallcaps'

elif self.attrib['effect'] == 'normal':
    emph = etree.Element('span')
    emph.attrib['data-class'] = 'normal'

emph.text = self.text
return etree.tostring(emph)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//problem-set/entry/solution//correct</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html learner correct teacher">
return self.text
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part</xpath>
    <attributes>
      <entry>
	<name>style:columns</name>
	<type>integer(1,)</type>
	<default>1</default>
      </entry>
    </attributes>
    <children>
      <optional>shortcode</optional>
      <optional>header</optional>
      <any-number>
	<one-of>
	  <element>multi-part</element>
	  <element>entry</element>
	  <element>monassis-template</element>
	</one-of>
      </any-number>
      <optional>footer</optional>
    </children>
    <notext/>
    <conversion-callback name="latex html learner teacher">
return convert_using(self, '/document/content//exercises//problem-set')
    </conversion-callback>
    <conversion-callback name="latex correct">
return convert_using(self, '/document/content//exercises//problem-set')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/header</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex html learner teacher">
return convert_using(self, '/document/content//exercises//problem-set/header')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/footer</xpath>
    <children>
      <reference>block-element-no-subsections</reference>
    </children>
    <notext/>
    <conversion-callback name="latex html learner teacher">
return convert_using(self, '/document/content//exercises//problem-set/footer')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/entry</xpath>
    <children>
      <element>problem</element>
      <element>solution</element>
      <optional>correct</optional>
    </children>
    <notext/>
    <validation-callback>problemset_entry_contains_correct_and_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
return convert_using(self, '/document/content//exercises//problem-set/entry')
    </conversion-callback>
    <conversion-callback name="latex html correct">
return convert_using(self, '/document/content//exercises//problem-set/entry')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/shortcode</xpath>
    <validation-callback>is_exercise_shortcode</validation-callback>
    <conversion-callback name="latex html learner teacher">
# Store shortcode in parent problem-set
problemsetParent = self.getparent().getparent()
if problemsetParent.tag == 'problem-set': # multi-part can also have multi-part as a parent
    count = int(problemsetParent.attrib.get('problem-set-entry-count', 0)) + 1
    shortcodes = eval(problemsetParent.attrib.get('shortcodes', '{}'))
    shortcodes[count] = self.text
    problemsetParent.attrib['shortcodes'] = repr(shortcodes)
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/entry/problem</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html learner teacher">
return convert_using(self, '/document/content//exercises//problem-set/entry/problem')
    </conversion-callback>
    <conversion-callback name="latex html correct">
return convert_using(self, '/document/content//exercises//problem-set/entry/problem')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/entry/solution</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>url</name>
	<type>url</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html teacher">
return convert_using(self, '/document/content//exercises//problem-set/entry/solution')
    </conversion-callback>
    <conversion-callback name="latex html learner correct">
return convert_using(self, '/document/content//exercises//problem-set/entry/solution')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/entry/correct</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html correct">
return convert_using(self, '/document/content//exercises//problem-set/entry/correct')
    </conversion-callback>
    <conversion-callback name="latex html learner teacher"/>
  </entry>

  <entry>
    <xpath>/document/content//exercises//multi-part/entry/solution//correct</xpath>
    <children>
      <one-of>
	<reference>block-element-no-subsections</reference>
	<reference>inline-element</reference>
      </one-of>
    </children>
    <conversion-callback name="latex html learner correct teacher">
return convert_using(self, '/document/content//exercises//problem-set/entry/solution//correct')
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//nth</xpath>
    <attributes>
      <entry>
	<name>format</name>
	<type>enum("word","superscript")</type>
	<default>word</default>
      </entry>
    </attributes>
    <conversion-callback name="latex html learner correct teacher">
try:
    value = int(self.text)
    isInt = True
except ValueError:
    value = self.text.strip()
    isInt = False

format = self.attrib['format']
if (format == 'word') and isInt and (value &lt; 12):
    return ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'eleventh'][value-1]
else:
    # format == 'superscript'
    if isInt:
        if (value % 10 == 1) and (value//10 % 10 != 1):
            suffix = 'st'
        elif (value % 10 == 2) and (value//10 % 10 != 1):
            suffix = 'nd'
        elif (value % 10 == 3) and (value//10 % 10 != 1):
            suffix = 'rd'
        else:
            suffix = 'th'
        value = str(value)
    else:
        suffix = 'th'
    return r'\(' + value + r'^{\text{' + suffix + r'}}\)'
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//link</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>url</name>
	<type>url</type>
	<default/>
      </entry>
      <entry>
	<name>target-id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>window</name>
	<type>string</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <reference>inline-element</reference>
    </children>
    <validation-callback>check_link_element</validation-callback>
    <conversion-callback name="latex learner correct teacher">
target = self.attrib.get('target-id')
if target is not None:
    return r'\REF{' + target + '}'
url = self.attrib.get('url')
if url is not None:
    if self.text != '':
        return r'\HREF{' + escape_latex(url) + '}{' + escape_latex(self.text) + '}'
    else:
        return r'\URL{' + escape_latex(url) + '}'
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
target = self.attrib.get('target-id')
link = etree.Element('a')
if target is not None:
    link.attrib['href'] = '#'+target
    link.text = target
    link.attrib['data-class'] = 'InternalLink'
    return etree.tostring(link)
url = self.attrib.get('url')
if url is not None:
    link.attrib['data-class'] = 'ExternalLink'
    if self.text != '':
        link.text = self.text
        link.attrib['href'] = url
        return etree.tostring(link)
    else:
        link.text = self.text
        link.attrib['href'] = url
        return etree.tostring(link)
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//sub</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
return r'$_{\text{%s}}$'%self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return self
    </conversion-callback>
  </entry>
  </entry>

  <entry>
    <xpath>/document/content//sup</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="latex learner correct teacher">
return r'$^{\text{%s}}$'%self.text
    </conversion-callback>
    <conversion-callback name="html learner correct teacher">
return self
    </conversion-callback>
  </entry>

  <entry>
    <xpath>/document/content//sup</xpath>
    <children>
      <reference>inline-element</reference>
    </children>
    <conversion-callback name="html latex learner correct teacher">
return etree.tostring(self)
    </conversion-callback>
  </entry>
  
  <entry>
    <xpath>//its:rules</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>version</name>
	<type>string</type>
	<default/>
      </entry>
    </attributes>
    <children>
      <any-number>
	<element>its:translateRule</element>
      </any-number>
    </children>
    <notext/>
    <conversion-callback name="html latex learner correct teacher">
return ''
    </conversion-callback>
  </entry>

  <entry>
    <xpath>//its:rules/its:translateRule</xpath>
    <attributes>
      <entry>
	<name>id</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>translate</name>
	<type>string</type>
	<default/>
      </entry>
      <entry>
	<name>selector</name>
	<type>string</type>
	<default/>
      </entry>
    </attributes>
    <notext/>
    <conversion-callback name="latex html learner correct teacher">
return ''
    </conversion-callback>
  </entry>

</spec>
